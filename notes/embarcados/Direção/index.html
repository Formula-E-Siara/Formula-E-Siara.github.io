<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="[!tip] Não repare a bagunça, esse tópico ainda ta sendo organizado . . &mldr;🐌
 1. Acionamento motor por BT (HSS86) 1."><title>Direção</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://formula-e-siara.github.io//icon.png><link href=https://formula-e-siara.github.io/styles.d1f618e3ba2094324ff83befd3fc8933.min.css rel=stylesheet><link href=https://formula-e-siara.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://formula-e-siara.github.io/js/darkmode.4df16aa1f8ed0e938ee741580ea6d83d.min.js></script>
<script src=https://formula-e-siara.github.io/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://formula-e-siara.github.io/js/popover.abe6a51cc7138c5dff00f151dd627ad1.min.js></script>
<script src=https://formula-e-siara.github.io/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://formula-e-siara.github.io/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://formula-e-siara.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://formula-e-siara.github.io/",fetchData=Promise.all([fetch("https://formula-e-siara.github.io/indices/linkIndex.f2e7f176ae978c6eac68dd18311d28c2.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://formula-e-siara.github.io/indices/contentIndex.cd5f67e786a456254ff308020491f193.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://formula-e-siara.github.io",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://formula-e-siara.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/formula-e-siara.github.io\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://formula-e-siara.github.io/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://formula-e-siara.github.io/>Fórmula-E Siará Wiki</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Direção</h1><p class=meta>Last updated
Jan 3, 2023</p><ul class=tags><li><a href=https://formula-e-siara.github.io/tags/el%C3%A9trica/>Elétrica</a></li><li><a href=https://formula-e-siara.github.io/tags/powertrain/>Powertrain</a></li></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#11-motor-de-passo>1.1. Motor de passo</a><ol><li><a href=#111-diagrama-de-conexão>1.1.1. Diagrama de conexão</a></li><li><a href=#112-fios-encoder-motor>1.1.2. Fios encoder motor</a></li><li><a href=#113-conexão-encoder-com-driver-hss86>1.1.3. Conexão encoder com driver HSS86</a></li></ol></li><li><a href=#12-hybrid-servo-driver-tma-des-hss86>1.2. Hybrid Servo Driver (TMA DES HSS86)</a><ol><li><a href=#121-luz-segurança>1.2.1. Luz segurança</a></li><li><a href=#122-configuração-dos-switches>1.2.2. Configuração dos switches</a></li><li><a href=#123-controlador>1.2.3. Controlador</a></li></ol></li></ol><ol><li><a href=#21-controlando-por-celular-provisório>2.1. Controlando por celular (Provisório)</a><ol><li><a href=#211-esp-portas-bt>2.1.1. ESP (portas BT)</a></li><li><a href=#212-saída-esp>2.1.2. (Saída ESP)</a></li><li><a href=#213-alimentação-esp>2.1.3. (Alimentação ESP)</a></li><li><a href=#214-aplicativo-para-controlar-pelo-celular>2.1.4. Aplicativo para controlar pelo celular</a></li><li><a href=#215-rmt>!2.1.5. RMT</a></li></ol></li><li><a href=#22-possibilidades>2.2. Possibilidades</a><ol><li><a href=#221-phantom-4>2.2.1. Phantom 4</a></li><li><a href=#222-arduino--módulo-wifi>2.2.2. Arduino + módulo WiFi</a></li><li><a href=#223-esp-para-raspberry-spi>2.2.3. ESP para Raspberry (SPI)</a></li><li><a href=#224-esp-para-raspberry-can>!2.2.4. ESP para Raspberry (CAN)</a></li></ol></li></ol><ol><li><a href=#31-possibilidades>3.1. Possibilidades</a><ol><li><a href=#311-encoder-externo>3.1.1. Encoder externo</a></li><li><a href=#312-software-hss86>3.1.2. Software HSS86</a></li><li><a href=#313-encoder-do-próprio-motor>3.1.3. Encoder do próprio motor</a></li></ol></li></ol></nav></details></aside><blockquote class=tip-callout><p>Não repare a bagunça, esse tópico ainda ta sendo organizado . . &mldr;🐌</p></blockquote><a href=#1-acionamento-motor-por-bt-hss86><h1 id=1-acionamento-motor-por-bt-hss86><span class=hanchor arialabel=Anchor># </span>1. Acionamento motor por BT (HSS86)</h1></a><a href=#11-motor-de-passo><h2 id=11-motor-de-passo><span class=hanchor arialabel=Anchor># </span>1.1. Motor de passo</h2></a><p><img src=https://formula-e-siara.github.io//notes/images/direcao_motor_driver.png width=auto alt></p><p>O motor utilizado para o projeto da direção elétrica será o Tecmaf 34080 (
<a href=https://tecmaf.com.br/wp-content/uploads/2020/07/TMA.ES_.34080.pdf rel=noopener>TMA.ES 34080</a>), motor de passo bipolar com força de 8 Nm, tal que cada passo equivale a um ângulo de 1,8°± 5%. Algumas informações sobre o motor:</p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_motor.png width=auto alt></p><p>O acionamento do motor está sendo feito com o apoio do driver dedicado (
<a href=https://www.jbcnc.se/images/datasheets/HSS86.pdf rel=noopener>HSS86</a>). O driver permite muitas funcionalidades úteis, entre elas:</p><ul><li>Controle em malha fechada do motor que não permite a perda de passo;</li><li>Melhoria na performance em alta velocidade e alto torque;</li><li>Ajuste automático de corrente baseado na carga de trabalho reduzindo o aquecimento;</li><li>Frequência de resposta de pulso de 200 kHz;</li><li>Possibilidade de escolha entre 16 micropassos (em escala de 400 a 51200 crosteps/rev) através das chaves físicas na lateral do driver.</li><li>Proteção contra sobrecorrente, sobretensão e diferença de posição.</li></ul><a href=#111-diagrama-de-conexão><h3 id=111-diagrama-de-conexão><span class=hanchor arialabel=Anchor># </span>1.1.1. Diagrama de conexão</h3></a><p><img src=https://formula-e-siara.github.io//notes/images/direcao_esquema_hss86.png width=auto alt></p><a href=#112-fios-encoder-motor><h3 id=112-fios-encoder-motor><span class=hanchor arialabel=Anchor># </span>1.1.2. Fios encoder motor</h3></a><p><img src=https://formula-e-siara.github.io//notes/images/direcao_db15_cores.png width=auto alt></p><a href=#113-conexão-encoder-com-driver-hss86><h3 id=113-conexão-encoder-com-driver-hss86><span class=hanchor arialabel=Anchor># </span>1.1.3. Conexão encoder com driver HSS86</h3></a><p><img src=https://formula-e-siara.github.io//notes/images/direcao_conexao_encoder_hss86.png width=auto alt></p><p> </p><a href=#12-hybrid-servo-driver-tma-des-hss86><h2 id=12-hybrid-servo-driver-tma-des-hss86><span class=hanchor arialabel=Anchor># </span>1.2. Hybrid Servo Driver (TMA DES HSS86)</h2></a><a href=#121-luz-segurança><h3 id=121-luz-segurança><span class=hanchor arialabel=Anchor># </span>1.2.1. Luz segurança</h3></a><p><img src=https://formula-e-siara.github.io//notes/images/direcao_luz_seg_hss86.png width=auto alt></p><a href=#122-configuração-dos-switches><h3 id=122-configuração-dos-switches><span class=hanchor arialabel=Anchor># </span>1.2.2. Configuração dos switches</h3></a><p>Usaremos configuração default. Para acionamento do motor não precisa tanta precisão</p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_microstep.png width=auto alt></p><p>ou seja, todas as chaves devem ficar em on</p><a href=#123-controlador><h3 id=123-controlador><span class=hanchor arialabel=Anchor># </span>1.2.3. Controlador</h3></a><blockquote class=attention-callout><p>Observação importante: Ligar o motor e driver com cabo desconectado poderá danificar o driver e o encoder</p></blockquote><p>Estaremos usando o arduino que tem tensão de sinal de 5V logo não precisa dos resistores conforme tabela abaixo. Para teste com esp (próximo tópico), usaremos um optacoplador ligado aos pinos de saída, assim escolhemos a resistência de 2,2k pois usaremos 24V para dar maior margem para caso haja queda de tensão (checar diagrama 1.1.1.)</p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_pinos_controle_hss86.png width=auto alt></p><a href=#pinos-hss86><h4 id=pinos-hss86><span class=hanchor arialabel=Anchor># </span>Pinos (HSS86)</h4></a><p>-       ENA (Enable): HIGH habilita o motor (considerando acionamento em HIGH conforme diagrama do datasheet do HSS86)
-       DIR (Direction): HIGH horário/ LOW anti horário.
-       PUL (Pulse): Esta é a entrada de pulso do HSS86. Quando um pulso de sinal lógico alto é aplicado a essa entrada, o motor avança um passo ou uma posição. O número de pulsos necessários para um movimento completo depende das características do motor.</p><a href=#código-esp32><h4 id=código-esp32><span class=hanchor arialabel=Anchor># </span>Código (ESP32)</h4></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>const int pin_ena = 2; //habilita o motor
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>const int pin_dir = 3; //determina a direção
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>const int pin_pul = 4; //executa um passo
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int periodo = 1000; // micro segundos
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int step = 5; //Conta 400 pulsos
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>boolean pulso = LOW; //estado do pulso
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/*Para saber a velocidade e o quanto o motor vai girar defina qual a configuração
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>do &#34;divisor&#34; driver, 400 pulso/rev, 800pulso/rev 1600pulso/rev e etc
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>A velocidade será freq/divisor, onde freq= 1/periodo
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>EX: divisor default=400; periodo= 500us; freq=1/periodo= 1kHz
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Resulta em 1000(pulso/s)/400(pulso/rev)=2.5 rev/s e 2.5 rev/s = 150 rpm
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>- Se por exemplo step=400, sera executado 400 passos com o divisor fica
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>step/divisor=400(pulsos)/400(pulso/rev) que resulta em 1 rev.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>- Se sao 400 pulsos com velocidade 2.5 rev/s o tempo de 1 volta será de 1rev/2.5 0.4 segundos
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>*/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void setup(){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  pinMode(pin_ena, OUTPUT);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  pinMode(pin_dir, OUTPUT);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  pinMode(pin_pul, OUTPUT);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  digitalWrite(pin_ena, HIGH); //habilita em high, ligando portas positivas em high
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  digitalWrite(pin_dir, HIGH); // low ANTIHORARIO / high HORARIO
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  digitalWrite(pin_pul, LOW); //borda de decida
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void loop(){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  delay(1000);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  for(int i=0; i&lt;step; i++){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    pulso = !pulso; //inverte o estado da variável
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    digitalWrite(pin_pul, pulso); //atribui o novo estado à porta
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    delayMicroseconds(periodo*1000/2); //tempo em alta do pulso
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    pulso = !pulso; //inverte o estado da variável
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    digitalWrite(pin_pul, pulso); //atribui o novo estado à porta
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    delayMicroseconds(periodo*1000/2); //tempo em baixa do pulso
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#error><h4 id=error><span class=hanchor arialabel=Anchor># </span>Error</h4></a><p><img src=https://formula-e-siara.github.io//notes/images/direcao_error.png width=auto alt></p><a href=#2-controle-remoto><h1 id=2-controle-remoto><span class=hanchor arialabel=Anchor># </span>2. Controle remoto</h1></a><a href=#21-controlando-por-celular-provisório><h2 id=21-controlando-por-celular-provisório><span class=hanchor arialabel=Anchor># </span>2.1. Controlando por celular (Provisório)</h2></a><p>Celular(bluetooth) → ESP → optoacoplador → driver HSS86</p><a href=#211-esp-portas-bt><h3 id=211-esp-portas-bt><span class=hanchor arialabel=Anchor># </span>2.1.1. ESP (portas BT)</h3></a><p><img src=https://formula-e-siara.github.io//notes/images/direcao_pinout_esp32.png width=auto alt></p><a href=#212-saída-esp><h3 id=212-saída-esp><span class=hanchor arialabel=Anchor># </span>2.1.2. (Saída ESP)</h3></a><p>Necessário entre esp e driver pq saída esp é de 3,3V</p><a href=#optacoplador-tlp281-4><h4 id=optacoplador-tlp281-4><span class=hanchor arialabel=Anchor># </span>Optacoplador TLP281-4</h4></a><p>Prático 4 entradas -> 4 saídas
<img src=https://formula-e-siara.github.io//notes/images/direcao_TLP281_4.png width=auto alt></p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_TLP281-4_esquema.png width=auto alt></p><a href=#conversor-de-nível-lógico-33v-5v-bidirecional---2-canais><h4 id=conversor-de-nível-lógico-33v-5v-bidirecional---2-canais><span class=hanchor arialabel=Anchor># </span>Conversor de Nível Lógico 3.3V-5V Bidirecional - 2 Canais</h4></a><p>Sugestão do professor, mas não achamos no lab</p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_conversor_nivel_logico.png width=auto alt></p><a href=#optacoplador-hcpl-3120><h4 id=optacoplador-hcpl-3120><span class=hanchor arialabel=Anchor># </span>Optacoplador HCPL-3120</h4></a><p>tinhamos sobrando no lab</p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_HCPL_3120.png width=auto alt></p><blockquote class=attention-callout><p>É necessário uso de um capacitor de bypass de 0,1 μF entre os pinos 5 e 8</p></blockquote><p>Por datasheet do opta, temos:</p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_HCPL_3120_datasheet.png width=auto alt></p><a href=#input><h5 id=input><span class=hanchor arialabel=Anchor># </span>Input</h5></a><p>A tensão de entrada será da ESP32 que é de 3,3V, então o resistor de entrada deve ser 330Ω (Ωmin=3,3V/16mA=206Ω)</p><a href=#output><h5 id=output><span class=hanchor arialabel=Anchor># </span>Output</h5></a><blockquote class=attention-callout><p>É necessário se atentar à necessidade de resistência entre o controlador e o driver de acordo com a tensão de controle utilizada.
Pelo datasheet, temos:
<img src=https://formula-e-siara.github.io//notes/images/direcao_resistencia_hss86.png width=auto alt></p></blockquote><p>Usaremos alimentação de saída em 24V (tem q estar entre 15 e 30V e o datasheet do hss dá opção de 5V, 12V e 24V). Assim, lembrando pelo diagrama 1.1.1. e tabela 1.2.3. precisamos usar resistência de aproximamente 2k, usaremos 2k2 Ω</p><a href=#213-alimentação-esp><h3 id=213-alimentação-esp><span class=hanchor arialabel=Anchor># </span>2.1.3. (Alimentação ESP)</h3></a><p>A alimentação da esp pode ser feita pelo próprio conector USB (5,0V) ou então através do pino 5V ou VIN , com uma alimentação regulada de 5,0V</p><a href=#regulador-ka7805><h4 id=regulador-ka7805><span class=hanchor arialabel=Anchor># </span>Regulador KA7805</h4></a><p><img src=https://formula-e-siara.github.io//notes/images/direcao_KA7805.png width=auto alt></p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_KA7805_data1.png width=auto alt></p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_KA7805_data2.png width=auto alt></p><a href=#214-aplicativo-para-controlar-pelo-celular><h3 id=214-aplicativo-para-controlar-pelo-celular><span class=hanchor arialabel=Anchor># </span>2.1.4. Aplicativo para controlar pelo celular</h3></a><a href=#aplicativo-1-só-terminal-serial><h4 id=aplicativo-1-só-terminal-serial><span class=hanchor arialabel=Anchor># </span>Aplicativo 1: Só terminal Serial</h4></a><p><img src=https://formula-e-siara.github.io//notes/images/direcao_app1.jpg width=auto alt></p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_app1_example.jpg width=auto alt></p><a href=#código-acionamento-v1><h5 id=código-acionamento-v1><span class=hanchor arialabel=Anchor># </span>Código acionamento (v1)</h5></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#include &#34;BluetoothSerial.h&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>const int ena = 33; //habilita o motor
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>const int dir = 32; //determina a direção
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>const int pul = 3; //executa um passo
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>String comando;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int periodo = 500; // em ms, faixa sugerida de 100 a 2000 (obs colocar numero par)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int step = 4000; //Conta x pulsos
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>boolean pulso = LOW; //estado inicial do pulso
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int pul_rev;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int tempo;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int angulo;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int flag=0;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>String letra;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>BluetoothSerial SerialBT;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void setup() {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  Serial.begin(9600); // Inicializa a porta serial para depuração
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  pinMode(ena, OUTPUT);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  pinMode(dir, OUTPUT);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  pinMode(pul, OUTPUT);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  digitalWrite(ena, HIGH); //habilita em high, ligando portas positivas em high
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  digitalWrite(pul, LOW); //borda de decida
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  SerialBT.begin(&#34;Controle remoto&#34;); // Inicializa a comunicação Bluetooth
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void loop() {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  delay(500);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  while(!flag){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    SerialBT.println(&#34;Informe valor pul_rev definido nas chaves do HSS86&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    delay(5000);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if (SerialBT.available()) { // Verifica se há dados disponíveis na conexão Bluetooth
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      comando=SerialBT.readStringUntil(&#39;\n&#39;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      pul_rev=comando.toInt();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      SerialBT.println(&#34;Envie um comando&#34;);   
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      flag=1;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  if (SerialBT.available()) { // Verifica se há dados disponíveis na conexão Bluetooth
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    comando= SerialBT.readStringUntil(&#39;\n&#39;);  // Lê o comando enviado pelo dispositivo remoto
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    comando.replace(&#34;\n&#34;, &#34;&#34;); // Remove o caractere &#39;\n&#39; da string
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    letra=comando[0];
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    comando.replace(letra, &#34;&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    switch(letra[0]){     
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      //Direção
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;D&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;d&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        if(comando[0]==&#39;0&#39;){digitalWrite(dir, LOW); SerialBT.println(&#34;mudou dir pra 0&#34;);}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        else if(comando[1]==&#39;1&#39;){digitalWrite(dir, HIGH); SerialBT.println(&#34;mudou dir pra 1&#34;);   }   
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        else{SerialBT.println(&#34;Comando inválido3&#34;);}     
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      //Enable
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;E&#39;:   
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;e&#39; :
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        if(comando[0]==&#39;0&#39;){digitalWrite(ena, LOW);SerialBT.println(&#34;mudou ena pra 0&#34;);}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        else if(comando[1]==&#39;1&#39;){digitalWrite(ena, HIGH);SerialBT.println(&#34;mudou ena pra 1&#34;);}   
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        else{SerialBT.println(&#34;Comando inválido1&#34;);}     
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      //Periodo em ms, faixa sugerida de 100 a 2000 (obs colocar numero par)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;P&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;p&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        periodo=comando.toInt();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        SerialBT.println(&#34;periodo alterado&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        SerialBT.println(periodo);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      //Numero de passos (Steps)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;S&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;s&#39;:   
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        step=comando.toInt();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        SerialBT.println(&#34;step alterado&#34;);SerialBT.println(step);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      //Angulo de rotação em graus
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;A&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;a&#39;:         
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        angulo=comando.toInt(); 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        step=angulo*(pul_rev)/180;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        SerialBT.println(&#34;angulo alterado&#34;);SerialBT.println(angulo);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      //Tempo de acionamento em ms
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;T&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;t&#39;: 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        tempo=comando.toInt();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        SerialBT.println(&#34;tempo alterado&#34;);SerialBT.println(tempo);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        step=tempo*1000/periodo;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      default:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        SerialBT.println(&#34;Comando inválido2&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        break; 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  for(int i=0; i&lt;=step; i++){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    digitalWrite(pul, pulso); //atribui o novo estado à porta
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    delayMicroseconds(periodo/2); //tempo em alta do pulso
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    pulso = !pulso; //inverte o estado da variável
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    digitalWrite(pul, pulso); //atribui o novo estado à porta
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    delayMicroseconds(periodo/2); //tempo em baixa do pulso
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#código-acionamento-v2><h5 id=código-acionamento-v2><span class=hanchor arialabel=Anchor># </span>Código acionamento (v2)</h5></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span><span class=lnt>198
</span><span class=lnt>199
</span><span class=lnt>200
</span><span class=lnt>201
</span><span class=lnt>202
</span><span class=lnt>203
</span><span class=lnt>204
</span><span class=lnt>205
</span><span class=lnt>206
</span><span class=lnt>207
</span><span class=lnt>208
</span><span class=lnt>209
</span><span class=lnt>210
</span><span class=lnt>211
</span><span class=lnt>212
</span><span class=lnt>213
</span><span class=lnt>214
</span><span class=lnt>215
</span><span class=lnt>216
</span><span class=lnt>217
</span><span class=lnt>218
</span><span class=lnt>219
</span><span class=lnt>220
</span><span class=lnt>221
</span><span class=lnt>222
</span><span class=lnt>223
</span><span class=lnt>224
</span><span class=lnt>225
</span><span class=lnt>226
</span><span class=lnt>227
</span><span class=lnt>228
</span><span class=lnt>229
</span><span class=lnt>230
</span><span class=lnt>231
</span><span class=lnt>232
</span><span class=lnt>233
</span><span class=lnt>234
</span><span class=lnt>235
</span><span class=lnt>236
</span><span class=lnt>237
</span><span class=lnt>238
</span><span class=lnt>239
</span><span class=lnt>240
</span><span class=lnt>241
</span><span class=lnt>242
</span><span class=lnt>243
</span><span class=lnt>244
</span><span class=lnt>245
</span><span class=lnt>246
</span><span class=lnt>247
</span><span class=lnt>248
</span><span class=lnt>249
</span><span class=lnt>250
</span><span class=lnt>251
</span><span class=lnt>252
</span><span class=lnt>253
</span><span class=lnt>254
</span><span class=lnt>255
</span><span class=lnt>256
</span><span class=lnt>257
</span><span class=lnt>258
</span><span class=lnt>259
</span><span class=lnt>260
</span><span class=lnt>261
</span><span class=lnt>262
</span><span class=lnt>263
</span><span class=lnt>264
</span><span class=lnt>265
</span><span class=lnt>266
</span><span class=lnt>267
</span><span class=lnt>268
</span><span class=lnt>269
</span><span class=lnt>270
</span><span class=lnt>271
</span><span class=lnt>272
</span><span class=lnt>273
</span><span class=lnt>274
</span><span class=lnt>275
</span><span class=lnt>276
</span><span class=lnt>277
</span><span class=lnt>278
</span><span class=lnt>279
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#include &#34;BluetoothSerial.h&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>BluetoothSerial SerialBT;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//Definindo pinos
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>const int pin_ena = 15;                        //habilita o motor
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>const int pin_dir = 5;                        //determina a direção
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>const int pin_pul = 4;                        //executa um passo
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//Variaveis para leitura mensagem bt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>String comando;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>String letra;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//Variáveis para controle do motor
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>boolean direcao = HIGH;                       // low AH - high H
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>boolean enable = LOW;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>volatile boolean pulso = LOW;                          //estado inicial do pulso (borda de decida)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>volatile int step = 4000;                              //Conta x pulsos
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>volatile unsigned long periodo = 6;                              /* microsegundos (periodo minimo)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                                              Frequencia do driver 200kHz (ou seja, 1 pulso em 1/200k=0.005 ms=5us).
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                                              O ideal seria 2.5 (positivo e negativo), mas vamos trabalhar com margem*/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//Variáveis para calculo/conversão
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>volatile int tempo;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int angulo;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int pul_rev;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//Flags intermediarias
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int ang_neg=0;                                 //flag sinal angulo
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int flag=0;                                    //flag valor pul_rev recebido
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int stay=0;                                    //flag comando permanecer ligado
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void setup(){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  Serial.begin(9600);                          // Inicializa a porta serial para depuração
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  pinMode(pin_ena, OUTPUT);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  pinMode(pin_dir, OUTPUT);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  pinMode(pin_pul, OUTPUT);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  digitalWrite(pin_ena, enable);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  digitalWrite(pin_dir, direcao);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  digitalWrite(pin_pul, pulso);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  SerialBT.begin(&#34;Controle remoto&#34;); // Nome do dispositivo para comunicação BT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void loop(){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  //Pro calculo de tempo e angulo precisa saber o valor de pul_rev (chaves do hss86)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  while(!flag){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    SerialBT.println(&#34;Informe valor pul_rev definido nas chaves do HSS86&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    delay(5000);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if (SerialBT.available()) { //Verifica se há dados disponíveis na conexão Bluetooth
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      comando=SerialBT.readStringUntil(&#39;\n&#39;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      pul_rev=comando.toInt();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      switch(pul_rev){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        case 400:   case 800:   case 1000:  case 1600:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        case 2000:  case 3200:  case 4000:  case 5000:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        case 6400:  case 8000:  case 10000: case 12800:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        case 20000: case 25600: case 40000: case 51200:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            SerialBT.print(&#34;Pul_rev = &#34;);  SerialBT.println(pul_rev);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            SerialBT.println(&#34;Envie um comando&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            flag=1;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        default:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          SerialBT.println(&#34;ERRO1. Obs: default=400&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  if (SerialBT.available()) {                 // Verifica se há dados disponíveis na conexão Bluetooth
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //Tratar comando recebido
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    comando= SerialBT.readStringUntil(&#39;\n&#39;);  // Lê o comando enviado pelo dispositivo remoto
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    comando.replace(&#34;\n&#34;, &#34;&#34;);                // Remove o caractere &#39;\n&#39; da string
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    letra=comando[0];
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    comando.replace(letra, &#34;&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    switch(letra[0]){ 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      //Direção
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;D&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;d&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        if(comando[0]==&#39;0&#39;){direcao=0;}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        else if(comando[0]==&#39;1&#39;){direcao=1;}   
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        else{SerialBT.println(&#34;\nERRO2\nValor de direção invalida&#34;);}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        digitalWrite(pin_dir, direcao);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      //Enable
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;E&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;e&#39; :
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        if(comando[0]==&#39;0&#39;){enable=0;}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        else if(comando[0]==&#39;1&#39;){enable=1;}   
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        else{SerialBT.println(&#34;\nERRO3\nValor de enable invalido&#34;);}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        digitalWrite(pin_ena, enable);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      //Periodo em us
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;P&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;p&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        periodo=comando.toInt();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      //Numero de passos (Steps)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;S&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;s&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        if(comando[0]==&#39;.&#39;){SerialBT.println(&#34;Modo ligado até comando stop&#34;); step=1; stay=1;}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        else{step=comando.toInt();}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      //Angulo de rotação em graus
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;A&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;a&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        if(comando[0]==&#39;-&#39;){ang_neg=1; direcao=0; comando.replace(&#34;-&#34;, &#34;&#34;);}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        else{ang_neg=0; direcao=1;}     
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        digitalWrite(pin_dir, direcao);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        angulo=comando.toInt(); 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        step=angulo*(pul_rev)/360;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      /*
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      Não consegui corrigir o tempo, quando envio o comando, a esp desconecta     
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      //Tempo de acionamento em s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;T&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;t&#39;: 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        tempo=comando.toInt();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        periodo=tempo*1000000/step;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      */
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      default:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        SerialBT.println(&#34;\nERRO4&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if(periodo&lt;5){periodo=6;SerialBT.println(&#34;\nERRO5\nOBS: Periodo mínimo = 5us (fmax=200kHz). Periodo setado para 6us&#34;);}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    SerialBT.printf(&#34;\nperiodo(us) = %i\nstep = %i\ndirecao = %i\nenable =  %i\n&#34;,periodo,step,direcao,enable);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if(enable){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      SerialBT.println(&#34;\nIniciado&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      for(int i=0; i&lt;step; i++){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        pulso = !pulso;                                    //inverte o estado da variável
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        digitalWrite(pin_pul, pulso);                      //atribui o novo estado à porta
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        delayMicroseconds(((   periodo/2  )*2)/2);         //tempo em alta do pulso (divide por 2 e multiplica por 2 pra ter certeza q vai ser inteiro)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        pulso = !pulso;                                    //inverte o estado da variável
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        digitalWrite(pin_pul, pulso);                      //atribui o novo estado à porta
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        delayMicroseconds(((   periodo/2  )*2)/2);         //tempo em baixa do pulso (divide por 2 e multiplica por 2 pra ter certeza q vai ser inteiro)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        if(stay){i--;}                                     //Decrementa contador, mantem loop infinito
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        if (SerialBT.available()) {                        // Verifica se há dados disponíveis na conexão Bluetooth
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          //tratamento comando recebido bt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          comando= SerialBT.readStringUntil(&#39;\n&#39;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          comando.replace(&#34;\n&#34;, &#34;&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          if(comando==&#34;stop&#34;){SerialBT.println(&#34;Forçada parada&#34;); i=step;stay=0;}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      enable=0;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      //se o angulo foi colocado como negativo, é preciso corrigir o sentido de giro apos comando
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      if(ang_neg){direcao=1; ang_neg=0;digitalWrite(pin_dir, direcao);}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    SerialBT.println(&#34;\nEnvie um comando&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#aplicativo-2-controle-remoto><h4 id=aplicativo-2-controle-remoto><span class=hanchor arialabel=Anchor># </span>Aplicativo 2: Controle remoto</h4></a><p><img src=https://formula-e-siara.github.io//notes/images/direcao_app2.png width=auto alt></p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_app2_comandos.png width=auto alt></p><p>Usaremos:
-       L (left)
-       R (right)
-       S (stop)
-       0 - 9 + q (speed)
-       D (close app)</p><a href=#código-acionamento-v3><h5 id=código-acionamento-v3><span class=hanchor arialabel=Anchor># </span>Código acionamento (v3)</h5></a><p>o valor pmin=166 foi obtido por estresse do motor em teste de bancada, maior velocidade para que não perca o passo na velocidade máxima (9)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#include &#34;BluetoothSerial.h&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>BluetoothSerial SerialBT;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//Definindo pinos
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>const int pin_ena = 15;                       //habilita o motor
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>const int pin_dir = 2;                        //determina a direção
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>const int pin_pul = 4;                        //executa um passo
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//Variaveis para leitura mensagem bt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>String comando;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//Variáveis para controle do motor
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>boolean direcao = HIGH;                               // low AH - high H
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>boolean enable = LOW;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int pmin=166;                                         //Para caso de pul_rev 400 (Experimental)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int velocidade=0;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>volatile boolean pulso = LOW;                         //estado inicial do pulso (borda de decida)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>volatile unsigned long periodo = pmin;                /* microsegundos (periodo minimo)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                                                      Frequencia do driver 200kHz (ou seja, 1 pulso em 1/200k=0.005 ms=5us).
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                                                      O ideal seria 2.5 (positivo e negativo), mas vamos trabalhar com margem*/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void setup(){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  Serial.begin(9600);                        // Inicializa a porta serial para depuração
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  pinMode(pin_ena, OUTPUT);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  pinMode(pin_dir, OUTPUT);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  pinMode(pin_pul, OUTPUT);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  digitalWrite(pin_ena, enable);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  digitalWrite(pin_dir, direcao);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  digitalWrite(pin_pul, pulso);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  SerialBT.begin(&#34;Controle remoto&#34;); // Nome do dispositivo para comunicação BT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void loop(){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  if (SerialBT.available()) {                 // Verifica se há dados disponíveis na conexão Bluetooth
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //Tratar comando recebido
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    comando= char(SerialBT.read());                 // Lê o comando enviado pelo dispositivo remoto
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    switch(comando[0]){ 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      //L (left)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;L&#39;:
</span></span><span class=line><span class=cl>        enable=1;direcao=0;
</span></span><span class=line><span class=cl>        //Serial.print(comando);Serial.println(&#34; -&gt; d0&#34;);
</span></span><span class=line><span class=cl>      break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      //R (right)
</span></span><span class=line><span class=cl>      case &#39;R&#39;:
</span></span><span class=line><span class=cl>        enable=1;direcao=1;
</span></span><span class=line><span class=cl>        //Serial.print(comando);Serial.println(&#34; -&gt; d1&#34;);
</span></span><span class=line><span class=cl>      break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      //S(stop)
</span></span><span class=line><span class=cl>      case &#39;S&#39;:
</span></span><span class=line><span class=cl>      case &#39;D&#39;:
</span></span><span class=line><span class=cl>        enable=0;
</span></span><span class=line><span class=cl>        //Serial.print(comando);Serial.println(&#34; -&gt; e0&#34;);
</span></span><span class=line><span class=cl>      break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      //Speed
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;:
</span></span><span class=line><span class=cl>      case &#39;4&#39;: case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;:
</span></span><span class=line><span class=cl>      case &#39;8&#39;: case &#39;9&#39;:
</span></span><span class=line><span class=cl>        velocidade=comando.toInt();
</span></span><span class=line><span class=cl>        periodo=pmin*(1+(10-velocidade)/2);
</span></span><span class=line><span class=cl>        //PA com razao sendo metade do periodo minimo
</span></span><span class=line><span class=cl>        //Serial.print(comando);Serial.printf(&#34; p%i\n&#34;,periodo);
</span></span><span class=line><span class=cl>      break;
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>      case &#39;q&#39;:
</span></span><span class=line><span class=cl>        velocidade=10;
</span></span><span class=line><span class=cl>        periodo=pmin*(1+(10-velocidade)/2);
</span></span><span class=line><span class=cl>        //PA com razao sendo metade do periodo minimo
</span></span><span class=line><span class=cl>        //Serial.print(comando);Serial.printf(&#34; p%i\n&#34;,periodo);
</span></span><span class=line><span class=cl>      break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      default:
</span></span><span class=line><span class=cl>        Serial.println(&#34;\nERRO4&#34;);
</span></span><span class=line><span class=cl>      break;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    digitalWrite(pin_ena, enable);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    digitalWrite(pin_dir, direcao);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Serial.print(&#34; p&#34;);Serial.print(periodo);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Serial.print(&#34; d&#34;);Serial.print(direcao);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Serial.print(&#34; e&#34;);Serial.println(enable);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    //Serial.printf(&#34;\nperiodo(us) = %i\nstep = %i\ndirecao = %i\nenable =  %i\n&#34;,periodo,step,direcao,enable);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    while(enable &amp;&amp; comando[0]!=&#39;D&#39; &amp;&amp; comando[0]!=&#39;S&#39;){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      pulso = !pulso;                                    //inverte o estado da variável
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      digitalWrite(pin_pul, pulso);                      //atribui o novo estado à porta
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      delayMicroseconds(((   periodo/2  )*2)/2);         //tempo em alta do pulso (divide por 2 e multiplica por 2 pra ter certeza q vai ser inteiro)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      pulso = !pulso;                                    //inverte o estado da variável
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      digitalWrite(pin_pul, pulso);                      //atribui o novo estado à porta
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      delayMicroseconds(((   periodo/2  )*2)/2);         //tempo em baixa do pulso (divide por 2 e multiplica por 2 pra ter certeza q vai ser inteiro)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      if (SerialBT.available()) {                        // Verifica se há dados disponíveis na conexão Bluetooth
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        comando= char(SerialBT.read());
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#215-rmt><h3 id=215-rmt><span class=hanchor arialabel=Anchor># </span>!2.1.5. RMT</h3></a><p>O periférico RMT (Controle Remoto) do ESP32 foi projetado inicialmente para enviar e receber sinais infravermelhos de controle remoto, mas devido ao seu design pode ser usado para gerar vários tipos de sinais. Algumas funcionalidades:</p><ul><li>Transmitir ou receber sinais infravermelhos, com qualquer protocolo;</li><li>Gerador de sequência de uso geral;</li><li>Transmitir sinais em um loop controlado por hardware, com número finito ou infinito de vezes;</li><li>Transmissão simultânea multicanal</li></ul><p>Os dados são transmitidos em símbolos dividimos em 2 partes: </p><ul><li>Duração sinal (15 bit);</li><li>Nível do sinal (1 bit) - alto ou baixo;
<img src=https://formula-e-siara.github.io//notes/images/direcao_rmt1.png width=auto alt></li></ul><p>Sinal de saída:
<img src=https://formula-e-siara.github.io//notes/images/direcao_rmt2.png width=auto alt></p><p>É possível também fazer o processo contrário de armazenamento de onda
<img src=https://formula-e-siara.github.io//notes/images/direcao_rmt3.png width=auto alt></p><p>O RMT possui 8 canais, dos quais 6 estão disponíveis e podem ser mapeados para qualquer pino GPIO ( <em>Nota:</em> Pinos <code>P13</code>- <code>P18</code> só podem ser usados ​​como entradas).
<img src=https://formula-e-siara.github.io//notes/images/direcao_rmt4.png width=auto alt></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>#include &lt;driver/rmt.h&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>const rmt_channel_t canal_rmt = RMT_CHANNEL_7;  // define qual dos 7 canais rmt usaremos (cada um tem seu limite de resolução e largura de pulso)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>const int pin_pul = 4;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void setup() {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  rmt_config_t config; //criar variável para armazenar caracteristicas de config do canal rmt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  config.rmt_mode = RMT_MODE_TX; //configurado como transmissor
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  config.channel = canal_rmt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  config.gpio_num = GPIO_NUM_4;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  config.mem_block_num = 1; //alocar um bloco de memória para armazenar os dados de saída
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  config.tx_config.loop_en = false; //desativa modo repetição
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  config.tx_config.carrier_en = false;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  config.tx_config.idle_output_en = true;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  config.tx_config.idle_level = RMT_IDLE_LEVEL_LOW; //estado lógico durante o período ocioso
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  config.clk_div = 80; //clock da ESP32 é 80Mhz, ele estabelece que cada unidade de tempo nesse canal será de clk/80
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  rmt_config(&amp;config); //aplicar as configurações ao módulo RMT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  rmt_driver_install(config.channel, 0, 0); //instalar o driver RMT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void loop() {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  //uma unidade de tempo = 1us
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  rmt_item32_t item; //variavel para definir os níveis e durações dos pulsos a serem enviados.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  item.level0 = 1;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  item.duration0 = 100;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  item.level1 = 0;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  item.duration1 = 100;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  rmt_write_items(canal_rmt, &amp;item, 1, true); //demora 20us pra fazer esse comando.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><a href=#22-possibilidades><h2 id=22-possibilidades><span class=hanchor arialabel=Anchor># </span>2.2. Possibilidades</h2></a><ol><li>Bluetooth: O Bluetooth é uma tecnologia sem fio de curto alcance que é amplamente utilizada em dispositivos móveis, como smartphones e fones de ouvido. É relativamente fácil de configurar e oferece uma boa taxa de transferência de dados para distâncias de até 10 metros em ambientes internos.</li><li>WiFi: O WiFi é um protocolo de comunicação sem fio de médio alcance que é amplamente utilizado em redes domésticas e empresariais. É mais complexo de configurar do que o Bluetooth, mas oferece taxas de transferência de dados mais altas e uma cobertura de alcance mais ampla para distâncias de até cerca de 50 metros em ambientes internos.</li><li>Zigbee: Zigbee é um protocolo de comunicação sem fio de curto alcance que é frequentemente usado em sistemas de automação residencial e industrial. É especialmente adequado para aplicações que exigem baixo consumo de energia e comunicação confiável para distâncias de até cerca de 10 metros.</li><li>LoRa: LoRa é um protocolo de comunicação de longo alcance que é adequado para aplicações que exigem cobertura em grandes áreas. Embora a distância máxima de comunicação possa ser superior a vários quilômetros em condições ideais, a taxa de transferência de dados é relativamente baixa. Portanto, é mais adequado para aplicações que exigem comunicação de baixa taxa de dados, como monitoramento de sensores remotos.</li></ol><a href=#221-phantom-4><h3 id=221-phantom-4><span class=hanchor arialabel=Anchor># </span>2.2.1. Phantom 4</h3></a><p><img src=https://formula-e-siara.github.io//notes/images/direcao_phantom4.png width=auto alt></p><p>O controle remoto do Phantom 4 utiliza uma tecnologia de comunicação proprietária da DJI, chamada de Lightbridge, que não é diretamente compatível com microcontroladores convencionais, como o Arduino</p><a href=#222-arduino--módulo-wifi><h3 id=222-arduino--módulo-wifi><span class=hanchor arialabel=Anchor># </span>2.2.2. Arduino + módulo WiFi</h3></a><p><img src=https://formula-e-siara.github.io//notes/images/Arduino_WiFi.png width=auto alt></p><p><img src=https://formula-e-siara.github.io//notes/images/Arduino_WiFi2.png width=auto alt></p><a href=#223-esp-para-raspberry-spi><h3 id=223-esp-para-raspberry-spi><span class=hanchor arialabel=Anchor># </span>2.2.3. ESP para Raspberry (SPI)</h3></a><p>Uma opção seria a leitura do controle remoto  feita pela raspberry (controlador) tal que esta envie os sinais para esp (periférico) que controlará o driver</p><a href=#estudando-comunicação-spi><h4 id=estudando-comunicação-spi><span class=hanchor arialabel=Anchor># </span>Estudando Comunicação SPI</h4></a><p>Na comunicação serial síncrona introduzimos o conceito de mestre - escravo (controlador - periférico), com apenas um controlador. Ou seja, um mesmo sensor (periférico) não pode estar em duas redes distintas, cada uma com um mestre diferente.</p><p>Além disso, os barramentos são unidirecionais, ou seja, os sinais são definidos somente como enviado ou somente como recebido. Mas é possível envio e recebimento de sinal de forma simultânea (por barramentos diferentes)</p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_SPI.png width=auto alt></p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_SPI2.png width=auto alt></p><p>Possível atingir velocidades maiores de comunicação porque há pouca deformação do sinal utilizando dois canais separados</p><a href=#exemplo-ligação><h5 id=exemplo-ligação><span class=hanchor arialabel=Anchor># </span>Exemplo ligação</h5></a><p><img src=https://formula-e-siara.github.io//notes/images/direcao_SPI3.png width=auto alt></p><p>No SS, o dispositivo é selecionado quando este pino se encontra em nível baixo
MISO: serial data out (SDO)
MOSI: serial data in (SDI)</p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_SPI4.png width=auto alt></p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_SPI5.png width=auto alt></p><a href=#esp32-portas-spi><h4 id=esp32-portas-spi><span class=hanchor arialabel=Anchor># </span>ESP32 (portas spi)</h4></a><p><img src=https://formula-e-siara.github.io//notes/images/direcao_SPI6.png width=auto alt></p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_SPI7.png width=auto alt></p><p>SP0 and SP1 are used internally to communicate with the built-in flash memory, and you should not use them for other tasks.</p><a href=#224-esp-para-raspberry-can><h3 id=224-esp-para-raspberry-can><span class=hanchor arialabel=Anchor># </span>!2.2.4. ESP para Raspberry (CAN)</h3></a><a href=#protocolo-can><h4 id=protocolo-can><span class=hanchor arialabel=Anchor># </span>Protocolo CAN</h4></a><a href=#características-gerais><h5 id=características-gerais><span class=hanchor arialabel=Anchor># </span>Características gerais           </h5></a><p><img src=https://formula-e-siara.github.io//notes/images/direcao_CAN.png width=auto alt></p><p>Protocolo CAN (Controller Area Network) é um protocolo de comunicação serial simultânea:</p><ul><li>Síncrono: sincronização no início de cada mensagem enviada ao barramento;</li><li>Multicast: todas as mensagens são recebidas por todos os módulos da rede (cada ECU pode então ler os dados e decidir se os aceita ou ignora) ;</li><li>Multi-mestre: todos módulos podem ser mestre ou escravo em determinado momento (cada ECU pode assumir o controle do barramento e transmitir informações);</li><li>Transmite dados a uma taxa de até 1 Mbps em barramentos de até 40 metros (OBS: A velocidade de transmissão dos dados é proporcional ao comprimento do barramento) - Ver figura abaixo (para 125 kb/s pode chegar a 500 metros.);</li><li>Máximo de 8 bytes de informação útil por quadro, sendo possível fragmentação;</li><li>CSMA/CD with NDA: caso duas mensagens sejam enviadas ao barramento ao mesmo instante, o módulo de menor prioridade cessará sua transmissão e o de maior continuará enviando sua mensagem, sem ter que reiniciá-la, continua qnd o barramento estiver livre (o receptor armazena os bits recebidos até que a mensagem inteira seja enviada);</li><li>NRZ (Non Return to Zero): cada bit transmitido representa efetivamente um dado;</li><li>Protocolo regulado: ISO 11898.</li></ul><p><img src=https://formula-e-siara.github.io//notes/images/direcao_CAN2.png width=auto alt></p><p>O protocolo foi desenvolvido pela BOSCH</p><a href=#configuração-dos-fios><h5 id=configuração-dos-fios><span class=hanchor arialabel=Anchor># </span>Configuração dos fios</h5></a><p>Há três formas de construir o barramento (bus):</p><ul><li>2 fios (dados: CAN H - high e CAN L - low),</li><li>4 fios (dado + VCC e GND, para alimentação dos blocos subsequentes)</li><li>1 fio (Somente 1 fio de dado: CAN).</li></ul><p>O barramento é classificado como Par Trançado Diferencial (para 2 e 4 fios): os dados são interpretados pela análise da diferença de potencial entre os fios CAN H e CAN L, por isso não necessita blindagem (pois, caso haja efeito de campo externo, afetará ambos os sinais)</p><p>Para velocidades de comunicação acima de 250 kbit/s, é recomendado cabo em par trançado para a minimização de ruídos.</p><p>É recomendado um resistor externo de 120 Ω/0,25 W para a rede CAN. A secção transversal de cada um dos fios deve ser de no mínimo 0,35mm². Sem os resistores nas extremidades, o sinal pode refletir de volta e interferir no próximo sinal de dados vindo da linha.</p><a href=#formato-dos-dados><h5 id=formato-dos-dados><span class=hanchor arialabel=Anchor># </span>Formato dos dados</h5></a><p>Os dados são representados por bits recessivos e dominantes.</p><ul><li>==Bit 0==: é dominante, indica que um nó está transmitindo e que os demais devem esperar até que a transmissão termine antes de transmitir sua mensagem. </li><li>==Bit 1==: recessivo, ocorre quando a tensão em ambas as linhas é ajustada para 2,5V (ou seja, não há diferença de tensão). 
Após enviar um bit, cada módulo analisa o barramento e verifica se outro módulo na rede o sobrescreveu.</li></ul><p><img src=https://formula-e-siara.github.io//notes/images/direcao_CAN3.png width=auto alt></p><a href=#formatos-de-mensagem><h5 id=formatos-de-mensagem><span class=hanchor arialabel=Anchor># </span>Formatos de mensagem:</h5></a><p>As partes da mensagem são:
<strong>SOF</strong> : Start of Frame, indica se o barramento CAN está disponível para uso (se tem outro enviando mensagem)
<strong>ID</strong> : Identificador do quadro, especifica o que a mensagem significa e quem a está enviando. Menor ID maior prioridade
<strong>RTR</strong> : A Solicitação de Transmissão Remota indica se um nó envia dados ou solicita dados de outro nó.
<strong>Control</strong> : contém o <em>IDE</em> (bit de extensão do identificador - 11 bits) e <em>DLC</em> (Data Length Code - 4 bits) especifica quantos bytes de dados estarão na mensagem
<strong>Data</strong> : 8 bytes de informações reais
<strong>CRC</strong> : Verificação de redundância cíclica para detecção de erros
<strong>ACK</strong> : Confirma recebimento adequado dos dados pelo nó
<strong>EOF</strong> : Fim do frame</p><blockquote class=attention-callout><p>Os nós no barramento CAN não possuem IDs. Em vez disso, cada mensagem recebe um CAN ID exclusivo que indica sobre o que é a mensagem. Todos os nós recebem todas as mensagens e cada nó filtra as mensagens que são relevantes para ele.</p></blockquote><ul><li><p>==CAN 2.0A (padrão)==: Mensagens com identificador de 11 bits, até 2048 mensagens
<img src=https://formula-e-siara.github.io//notes/images/direcao_CAN4.png width=auto alt>
<img src=https://formula-e-siara.github.io//notes/images/direcao_CAN5.png width=auto alt></p></li><li><p>==CAN 2.0B (estendido)==: identificador de 29 bits, até  5,3*10⁶ de mensagens, entretanto há aumento no tempo de transmissão de cada mensagem
<img src=https://formula-e-siara.github.io//notes/images/direcao_CAN6.png width=auto alt>
<img src=https://formula-e-siara.github.io//notes/images/direcao_CAN7.png width=auto alt></p></li></ul><a href=#tipos-de-mensagens><h5 id=tipos-de-mensagens><span class=hanchor arialabel=Anchor># </span>Tipos de mensagens:</h5></a><ul><li><p>==Frame de Dados==: Contém os dados do emissor para o(s) receptor(es);
<img src=https://formula-e-siara.github.io//notes/images/direcao_CAN8.png width=auto alt></p></li><li><p>==Frame Remota==: É uma solicitação de dados partindo de um dos nós;
<img src=https://formula-e-siara.github.io//notes/images/direcao_CAN9.png width=auto alt></p></li><li><p>==Frame de Erro==: É um frame enviado por qualquer um dos nós ao identificar um erro no barramento e pode ser detectado por todos os nós;
<img src=https://formula-e-siara.github.io//notes/images/direcao_CAN10.png width=auto alt></p></li><li><p>==Frame de sobrecarga==: Serve para retardar o tráfego no barramento devido à sobrecarga de dados ou atraso em um ou mais nós.
<img src=https://formula-e-siara.github.io//notes/images/direcao_CAN11.png width=auto alt></p></li></ul><a href=#transceiver-mcp2515---controlador-can-stand-alone-com-interface-spi><h5 id=transceiver-mcp2515---controlador-can-stand-alone-com-interface-spi><span class=hanchor arialabel=Anchor># </span>Transceiver (MCP2515 -  Controlador CAN Stand-Alone com Interface SPI)</h5></a><p>O controlador
<a href=https://ww1.microchip.com/downloads/en/DeviceDoc/MCP2515-Stand-Alone-CAN-Controller-with-SPI-20001801J.pdf rel=noopener>MCP2515</a> (CI maior da placa) usa CAN 2.0B. O transceptor CAN
<a href=https://www.nxp.com/docs/en/data-sheet/TJA1050.pdf rel=noopener>TJA1050</a> (CI menor da placa) atua como um intermediário entre o mcp2515 e o barramento, permite que no máximo 110 nós sejam conectados ao barramento.</p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_MCP2515.png width=auto alt>
<img src=https://formula-e-siara.github.io//direcao_MCP2515_data.png width=auto alt></p><p>Por que usar MCP2515 se a ESP32 ja tem uma porta CAN interna? Existem aplicações que requerem mais de uma porta CAN, e o único recurso do ESP32 aplicável para isso é a interface SPI. Na verdade, hipoteticamente, você pode adicionar até seis portas CAN controladas por SPI ao ESP32</p><p>Apresenta cristal de 8MHz (deve ser informado durante a programação)
Funciona com 3,3V e 5V então não precisa de intermediário entre esp e mcp2515</p><p>Já vem com resistor embutido basta posicionar o jump abaixo. Se o módulo for o primeiro ou o último nó da rede CAN, então o jumper deve ser colocado. Se for um nó intermediário, o jumper deve ser removido.
<img src=https://formula-e-siara.github.io//direcao_mcp2515_res.png width=auto alt></p><a href=#pinout><h5 id=pinout><span class=hanchor arialabel=Anchor># </span>Pinout</h5></a><table><thead><tr><th>pino MCP2515</th><th>GPIO ESP</th></tr></thead><tbody><tr><td>cs</td><td>5</td></tr><tr><td>mosi</td><td>23</td></tr><tr><td>miso</td><td>19</td></tr><tr><td>sck</td><td>18</td></tr></tbody></table><p>O pino int gera uma interrupção quando uma mensagem válida é recebida e carregada em um dos buffers de recebimento.</p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_MCP2515_pinout.png width=auto alt></p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_ESP_CAN_pinout.png width=auto alt></p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_mcp2515_montagem.png width=auto alt></p><p>Balbino me emprestou a esp dele: o pinout é diferente
<img src="/Pasted image 20230616171005.png" width=auto>
<img src="/Pasted image 20230616171148.png" width=auto></p><a href=#código><h5 id=código><span class=hanchor arialabel=Anchor># </span>Código</h5></a><p>==Código nó transmissor ==</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#include &lt;CAN.h&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void setup() {
</span></span><span class=line><span class=cl>  Serial.begin(9600);
</span></span><span class=line><span class=cl>  while (!Serial);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  Serial.println(&#34;CAN Sender&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  // start the CAN bus at 500 kbps
</span></span><span class=line><span class=cl>  if (!CAN.begin(500E3)) {
</span></span><span class=line><span class=cl>    Serial.println(&#34;Starting CAN failed!&#34;);
</span></span><span class=line><span class=cl>    while (1);
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void loop() {
</span></span><span class=line><span class=cl>  // send packet: id is 11 bits, packet can contain up to 8 bytes of data
</span></span><span class=line><span class=cl>  Serial.print(&#34;Sending packet ... &#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  CAN.beginPacket(0x12);
</span></span><span class=line><span class=cl>  CAN.write(&#39;h&#39;);
</span></span><span class=line><span class=cl>  CAN.write(&#39;e&#39;);
</span></span><span class=line><span class=cl>  CAN.write(&#39;l&#39;);
</span></span><span class=line><span class=cl>  CAN.write(&#39;l&#39;);
</span></span><span class=line><span class=cl>  CAN.write(&#39;o&#39;);
</span></span><span class=line><span class=cl>  CAN.endPacket();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  Serial.println(&#34;done&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  delay(1000);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  // send extended packet: id is 29 bits, packet can contain up to 8 bytes of data
</span></span><span class=line><span class=cl>  Serial.print(&#34;Sending extended packet ... &#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  CAN.beginExtendedPacket(0xabcdef);
</span></span><span class=line><span class=cl>  CAN.write(&#39;w&#39;);
</span></span><span class=line><span class=cl>  CAN.write(&#39;o&#39;);
</span></span><span class=line><span class=cl>  CAN.write(&#39;r&#39;);
</span></span><span class=line><span class=cl>  CAN.write(&#39;l&#39;);
</span></span><span class=line><span class=cl>  CAN.write(&#39;d&#39;);
</span></span><span class=line><span class=cl>  CAN.endPacket();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  Serial.println(&#34;done&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  delay(1000);
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>==Código nó receptor==</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#include &lt;CAN.h&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void setup() {
</span></span><span class=line><span class=cl>  Serial.begin(9600);
</span></span><span class=line><span class=cl>  while (!Serial);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  Serial.println(&#34;CAN Receiver Callback&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  // start the CAN bus at 500 kbps
</span></span><span class=line><span class=cl>  if (!CAN.begin(500E3)) {
</span></span><span class=line><span class=cl>    Serial.println(&#34;Starting CAN failed!&#34;);
</span></span><span class=line><span class=cl>    while (1);
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  // register the receive callback
</span></span><span class=line><span class=cl>  CAN.onReceive(onReceive);
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void loop() {
</span></span><span class=line><span class=cl>  // do nothing
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void onReceive(int packetSize) {
</span></span><span class=line><span class=cl>  // received a packet
</span></span><span class=line><span class=cl>  Serial.print(&#34;Received &#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  if (CAN.packetExtended()) {
</span></span><span class=line><span class=cl>    Serial.print(&#34;extended &#34;);
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  if (CAN.packetRtr()) {
</span></span><span class=line><span class=cl>    // Remote transmission request, packet contains no data
</span></span><span class=line><span class=cl>    Serial.print(&#34;RTR &#34;);
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  Serial.print(&#34;packet with id 0x&#34;);
</span></span><span class=line><span class=cl>  Serial.print(CAN.packetId(), HEX);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  if (CAN.packetRtr()) {
</span></span><span class=line><span class=cl>    Serial.print(&#34; and requested length &#34;);
</span></span><span class=line><span class=cl>    Serial.println(CAN.packetDlc());
</span></span><span class=line><span class=cl>  } else {
</span></span><span class=line><span class=cl>    Serial.print(&#34; and length &#34;);
</span></span><span class=line><span class=cl>    Serial.println(packetSize);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // only print packet data for non-RTR packets
</span></span><span class=line><span class=cl>    while (CAN.available()) {
</span></span><span class=line><span class=cl>      Serial.print((char)CAN.read());
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    Serial.println();
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  Serial.println();
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>**</p><a href=#3-encoder><h1 id=3-encoder><span class=hanchor arialabel=Anchor># </span>3. Encoder</h1></a><p><img src=https://formula-e-siara.github.io//notes/images/direcao_encoder.png width=auto alt></p><a href=#31-possibilidades><h2 id=31-possibilidades><span class=hanchor arialabel=Anchor># </span>3.1. Possibilidades</h2></a><a href=#311-encoder-externo><h3 id=311-encoder-externo><span class=hanchor arialabel=Anchor># </span>3.1.1. Encoder externo</h3></a><p>(Pegar os dados diretamente do motor)</p><p>teria que fazer uma redução com faixas escuras delimitadas para leitura por esse sensor. Ele envia luz e atua conforme a reflexão dela dada a sua reflexão.</p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_encoder2.png width=auto alt></p><p>Funciona como um amplificador. Mudando as resistências, altera a faixa que ele considera alta(3,3V) e baixa(0V). Assim, alteramos a sensibilidade do sensor (luz)</p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_encoder3.png width=auto alt></p><a href=#312-software-hss86><h3 id=312-software-hss86><span class=hanchor arialabel=Anchor># </span>3.1.2. Software HSS86</h3></a><p>(Pegar dos dados a partir do driver HSS86)</p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_soft_HSS86.png width=auto alt></p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_soft_HSS86_2.png width=auto alt></p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_soft_HSS86_3.png width=auto alt></p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_soft_HSS86_4.png width=auto alt></p><a href=#313-encoder-do-próprio-motor><h3 id=313-encoder-do-próprio-motor><span class=hanchor arialabel=Anchor># </span>3.1.3. Encoder do próprio motor</h3></a><a href=#leitura-encoder><h4 id=leitura-encoder><span class=hanchor arialabel=Anchor># </span>Leitura encoder</h4></a><p>Testes para p=1000us, pelo osciloscópio temos que o período do motor equivale a 400us para essa aplicação.</p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_teste_encoder.jpg width=auto alt>
Sinais ea+ e eb+ são defasados em 90 (sentido horário d1)</p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_teste_encoder2.jpg width=auto alt>
Sinais ea+ e eb+ são defasados em 90 (sentido anti horário d0)</p><p><img src=https://formula-e-siara.github.io//notes/images/direcao_teste_encoder3.jpg width=auto alt>
Sinais ea+ e ea- são opostos</p><a href=#esp32-attachinterrupt><h4 id=esp32-attachinterrupt><span class=hanchor arialabel=Anchor># </span>ESP32 (AttachInterrupt)</h4></a><p><img src=https://formula-e-siara.github.io//notes/images/direcao_pinout_attach.png width=auto alt></p><p>função <em>attachInterrupt</em>, cujo protótipo é <em>attachInterrupt(GPIOPin, ISR, Mode)</em>. Onde:</p><p>●     <strong>GPIOPin:</strong> número do GPIO que quer monitorar utilizando interrupção externa;</p><p>●     <strong>ISR:</strong> nome da função a ser chamada na hora de tratar a interrupção;</p><p>●     <strong>Mode:</strong> modo da interrupção (LOW, HIGH, RISING, FALLING ou CHANGE).</p><p>No ESP32, há os seguintes modos de interrupção suportados para os GPIOs:</p><p>●     <strong>FALLING:</strong> um modo que faz ser gerada uma interrupção quando um GPIO vai do nível alto (3V3) para nível baixo (0V). Ou seja, interrupção gerada na transição de nível alto para baixo;</p><p>●     <strong>RISING:</strong> um modo que faz ser gerada uma interrupção quando um GPIO vai do nível baixo (0V) para nível alto (3V3). Ou seja, interrupção gerada na transição de nível baixo para alto;</p><p>●     <strong>LOW:</strong> um modo que faz ser gerada uma interrupção gerada quando o GPIO está em nível baixo;</p><p>●     <strong>HIGH:</strong> um modo que faz ser gerada uma interrupção gerada quando o GPIO está em nível alto;</p><p>●     <strong>CHANGE:</strong> um modo que faz ser gerada uma interrupção quando há qualquer transição de nível no GPIO. Ou seja, tanto de nível baixo para alto quanto de nível alto para baixo.</p><a href=#código-encoder-falta-testar><h4 id=código-encoder-falta-testar><span class=hanchor arialabel=Anchor># </span>*Código encoder (falta testar)</h4></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span><span class=lnt>198
</span><span class=lnt>199
</span><span class=lnt>200
</span><span class=lnt>201
</span><span class=lnt>202
</span><span class=lnt>203
</span><span class=lnt>204
</span><span class=lnt>205
</span><span class=lnt>206
</span><span class=lnt>207
</span><span class=lnt>208
</span><span class=lnt>209
</span><span class=lnt>210
</span><span class=lnt>211
</span><span class=lnt>212
</span><span class=lnt>213
</span><span class=lnt>214
</span><span class=lnt>215
</span><span class=lnt>216
</span><span class=lnt>217
</span><span class=lnt>218
</span><span class=lnt>219
</span><span class=lnt>220
</span><span class=lnt>221
</span><span class=lnt>222
</span><span class=lnt>223
</span><span class=lnt>224
</span><span class=lnt>225
</span><span class=lnt>226
</span><span class=lnt>227
</span><span class=lnt>228
</span><span class=lnt>229
</span><span class=lnt>230
</span><span class=lnt>231
</span><span class=lnt>232
</span><span class=lnt>233
</span><span class=lnt>234
</span><span class=lnt>235
</span><span class=lnt>236
</span><span class=lnt>237
</span><span class=lnt>238
</span><span class=lnt>239
</span><span class=lnt>240
</span><span class=lnt>241
</span><span class=lnt>242
</span><span class=lnt>243
</span><span class=lnt>244
</span><span class=lnt>245
</span><span class=lnt>246
</span><span class=lnt>247
</span><span class=lnt>248
</span><span class=lnt>249
</span><span class=lnt>250
</span><span class=lnt>251
</span><span class=lnt>252
</span><span class=lnt>253
</span><span class=lnt>254
</span><span class=lnt>255
</span><span class=lnt>256
</span><span class=lnt>257
</span><span class=lnt>258
</span><span class=lnt>259
</span><span class=lnt>260
</span><span class=lnt>261
</span><span class=lnt>262
</span><span class=lnt>263
</span><span class=lnt>264
</span><span class=lnt>265
</span><span class=lnt>266
</span><span class=lnt>267
</span><span class=lnt>268
</span><span class=lnt>269
</span><span class=lnt>270
</span><span class=lnt>271
</span><span class=lnt>272
</span><span class=lnt>273
</span><span class=lnt>274
</span><span class=lnt>275
</span><span class=lnt>276
</span><span class=lnt>277
</span><span class=lnt>278
</span><span class=lnt>279
</span><span class=lnt>280
</span><span class=lnt>281
</span><span class=lnt>282
</span><span class=lnt>283
</span><span class=lnt>284
</span><span class=lnt>285
</span><span class=lnt>286
</span><span class=lnt>287
</span><span class=lnt>288
</span><span class=lnt>289
</span><span class=lnt>290
</span><span class=lnt>291
</span><span class=lnt>292
</span><span class=lnt>293
</span><span class=lnt>294
</span><span class=lnt>295
</span><span class=lnt>296
</span><span class=lnt>297
</span><span class=lnt>298
</span><span class=lnt>299
</span><span class=lnt>300
</span><span class=lnt>301
</span><span class=lnt>302
</span><span class=lnt>303
</span><span class=lnt>304
</span><span class=lnt>305
</span><span class=lnt>306
</span><span class=lnt>307
</span><span class=lnt>308
</span><span class=lnt>309
</span><span class=lnt>310
</span><span class=lnt>311
</span><span class=lnt>312
</span><span class=lnt>313
</span><span class=lnt>314
</span><span class=lnt>315
</span><span class=lnt>316
</span><span class=lnt>317
</span><span class=lnt>318
</span><span class=lnt>319
</span><span class=lnt>320
</span><span class=lnt>321
</span><span class=lnt>322
</span><span class=lnt>323
</span><span class=lnt>324
</span><span class=lnt>325
</span><span class=lnt>326
</span><span class=lnt>327
</span><span class=lnt>328
</span><span class=lnt>329
</span><span class=lnt>330
</span><span class=lnt>331
</span><span class=lnt>332
</span><span class=lnt>333
</span><span class=lnt>334
</span><span class=lnt>335
</span><span class=lnt>336
</span><span class=lnt>337
</span><span class=lnt>338
</span><span class=lnt>339
</span><span class=lnt>340
</span><span class=lnt>341
</span><span class=lnt>342
</span><span class=lnt>343
</span><span class=lnt>344
</span><span class=lnt>345
</span><span class=lnt>346
</span><span class=lnt>347
</span><span class=lnt>348
</span><span class=lnt>349
</span><span class=lnt>350
</span><span class=lnt>351
</span><span class=lnt>352
</span><span class=lnt>353
</span><span class=lnt>354
</span><span class=lnt>355
</span><span class=lnt>356
</span><span class=lnt>357
</span><span class=lnt>358
</span><span class=lnt>359
</span><span class=lnt>360
</span><span class=lnt>361
</span><span class=lnt>362
</span><span class=lnt>363
</span><span class=lnt>364
</span><span class=lnt>365
</span><span class=lnt>366
</span><span class=lnt>367
</span><span class=lnt>368
</span><span class=lnt>369
</span><span class=lnt>370
</span><span class=lnt>371
</span><span class=lnt>372
</span><span class=lnt>373
</span><span class=lnt>374
</span><span class=lnt>375
</span><span class=lnt>376
</span><span class=lnt>377
</span><span class=lnt>378
</span><span class=lnt>379
</span><span class=lnt>380
</span><span class=lnt>381
</span><span class=lnt>382
</span><span class=lnt>383
</span><span class=lnt>384
</span><span class=lnt>385
</span><span class=lnt>386
</span><span class=lnt>387
</span><span class=lnt>388
</span><span class=lnt>389
</span><span class=lnt>390
</span><span class=lnt>391
</span><span class=lnt>392
</span><span class=lnt>393
</span><span class=lnt>394
</span><span class=lnt>395
</span><span class=lnt>396
</span><span class=lnt>397
</span><span class=lnt>398
</span><span class=lnt>399
</span><span class=lnt>400
</span><span class=lnt>401
</span><span class=lnt>402
</span><span class=lnt>403
</span><span class=lnt>404
</span><span class=lnt>405
</span><span class=lnt>406
</span><span class=lnt>407
</span><span class=lnt>408
</span><span class=lnt>409
</span><span class=lnt>410
</span><span class=lnt>411
</span><span class=lnt>412
</span><span class=lnt>413
</span><span class=lnt>414
</span><span class=lnt>415
</span><span class=lnt>416
</span><span class=lnt>417
</span><span class=lnt>418
</span><span class=lnt>419
</span><span class=lnt>420
</span><span class=lnt>421
</span><span class=lnt>422
</span><span class=lnt>423
</span><span class=lnt>424
</span><span class=lnt>425
</span><span class=lnt>426
</span><span class=lnt>427
</span><span class=lnt>428
</span><span class=lnt>429
</span><span class=lnt>430
</span><span class=lnt>431
</span><span class=lnt>432
</span><span class=lnt>433
</span><span class=lnt>434
</span><span class=lnt>435
</span><span class=lnt>436
</span><span class=lnt>437
</span><span class=lnt>438
</span><span class=lnt>439
</span><span class=lnt>440
</span><span class=lnt>441
</span><span class=lnt>442
</span><span class=lnt>443
</span><span class=lnt>444
</span><span class=lnt>445
</span><span class=lnt>446
</span><span class=lnt>447
</span><span class=lnt>448
</span><span class=lnt>449
</span><span class=lnt>450
</span><span class=lnt>451
</span><span class=lnt>452
</span><span class=lnt>453
</span><span class=lnt>454
</span><span class=lnt>455
</span><span class=lnt>456
</span><span class=lnt>457
</span><span class=lnt>458
</span><span class=lnt>459
</span><span class=lnt>460
</span><span class=lnt>461
</span><span class=lnt>462
</span><span class=lnt>463
</span><span class=lnt>464
</span><span class=lnt>465
</span><span class=lnt>466
</span><span class=lnt>467
</span><span class=lnt>468
</span><span class=lnt>469
</span><span class=lnt>470
</span><span class=lnt>471
</span><span class=lnt>472
</span><span class=lnt>473
</span><span class=lnt>474
</span><span class=lnt>475
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>const int pinA = 34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>const int pinB = 35;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>const int debounceDelay = 50;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>volatile int stateA, stateB, prevStateA, prevStateB;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>volatile int counter = 0;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>unsigned long lastDebounceTime = 0;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void IRAM_ATTR isrA() {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  stateA = digitalRead(pinA);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  stateB = digitalRead(pinB);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  if (millis() - lastDebounceTime &gt; debounceDelay) {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if (prevStateA == LOW &amp;&amp; stateA == HIGH) {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      if (stateB == LOW) {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        counter++;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      } else {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        counter--;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    } else if (prevStateA == HIGH &amp;&amp; stateA == LOW) {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      if (stateB == LOW) {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        counter--;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      } else {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        counter++;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    prevStateA = stateA;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    prevStateB = stateB;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    lastDebounceTime = millis();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void IRAM_ATTR isrB() {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  stateA = digitalRead(pinA);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  stateB = digitalRead(pinB);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  if (millis() - lastDebounceTime &gt; debounceDelay) {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if (prevStateB == LOW &amp;&amp; stateB == HIGH) {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      if (stateA == LOW) {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        counter--;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      } else {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        counter++;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    } else if (prevStateB == HIGH &amp;&amp; stateB == LOW) {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      if (stateA == LOW) {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        counter++;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      } else {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        counter--;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    prevStateA = stateA;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    prevStateB = stateB;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    lastDebounceTime = millis();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void setup() {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  pinMode(pinA, INPUT);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  pinMode(pinB, INPUT);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  attachInterrupt(digitalPinToInterrupt(pinA), isrA, CHANGE);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  attachInterrupt(digitalPinToInterrupt(pinB), isrB, CHANGE);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  Serial.begin(9600);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void loop() {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  Serial.println(counter);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  delay(100);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>## 3.2. Dual core ESP32
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Para leitura do encoder e controle do motor simultâneo serão utilizados os 2 processadores da esp
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>### *Código Multitask (falta testar)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>#include &lt;BluetoothSerial.h&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>BluetoothSerial SerialBT;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>TaskHandle_t TaskBluetooth;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>TaskHandle_t TaskSerial;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>///////////////////////////////////Inicialização tarefa 1: Encoder ////////////////////////////////////////////
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//Definindo pinos
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>const int pin_ena = 15;                        //habilita o motor
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>const int pin_dir = 5;                        //determina a direção
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>const int pin_pul = 4;                        //executa um passo
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//Variaveis para leitura mensagem bt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>String comando;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>String letra;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//Variáveis para controle do motor
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>boolean direcao = HIGH;                       // low AH - high H
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>boolean enable = LOW;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>boolean pulso = LOW;                          //estado inicial do pulso (borda de decida)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int step = 4000;                              //Conta x pulsos
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int periodo = 6;                              /* microsegundos (periodo minimo)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                                              Frequencia do driver 200kHz (ou seja, 1 pulso em 1/200k=0.005 ms=5us).
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                                              O ideal seria 2.5 (positivo e negativo), mas vamos trabalhar com margem*/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//Variáveis para calculo/conversão
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int tempo;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int angulo;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int pul_rev;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//Flags intermediarias
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int ang_neg=0;                                 //flag sinal angulo
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int flag=0;                                    //flag valor pul_rev recebido
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int stay=0;                                    //flag comando permanecer ligado
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void setup() {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  Serial.begin(9600);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  pinMode(pin_ena, OUTPUT);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  pinMode(pin_dir, OUTPUT);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  pinMode(pin_pul, OUTPUT);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  digitalWrite(pin_ena, enable);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  digitalWrite(pin_dir, direcao);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  digitalWrite(pin_pul, pulso);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  SerialBT.begin(&#34;Controle remoto&#34;); // Nome do dispositivo para comunicação BT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  xTaskCreatePinnedToCore(
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    TaskBluetoothCode,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    &#34;Bluetooth&#34;,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    100000,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    NULL,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    1,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    &amp;TaskBluetooth,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  );
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  xTaskCreatePinnedToCore(
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    TaskSerialCode,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    &#34;Serial&#34;,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    10000,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    NULL,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    1,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    &amp;TaskSerial,
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  );
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void TaskBluetoothCode(void *pvParameters) {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  while (1) {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    while(!flag){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      SerialBT.println(&#34;Informe valor pul_rev definido nas chaves do HSS86&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      delay(5000);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        if (SerialBT.available()) { //Verifica se há dados disponíveis na conexão Bluetooth
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          comando=SerialBT.readStringUntil(&#39;\n&#39;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          pul_rev=comando.toInt();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          switch(pul_rev){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            case 400:   case 800:   case 1000:  case 1600:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            case 2000:  case 3200:  case 4000:  case 5000:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            case 6400:  case 8000:  case 10000: case 12800:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            case 20000: case 25600: case 40000: case 51200:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                SerialBT.print(&#34;Pul_rev = &#34;);  SerialBT.println(pul_rev);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                SerialBT.println(&#34;Envie um comando&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                flag=1;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            default:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>              SerialBT.println(&#34;ERRO1. Obs: default=400&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>              break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if (SerialBT.available()) {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      comando= SerialBT.readStringUntil(&#39;\n&#39;);  // Lê o comando enviado pelo dispositivo remoto
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      comando.replace(&#34;\n&#34;, &#34;&#34;);                // Remove o caractere &#39;\n&#39; da string
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      letra=comando[0];
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      comando.replace(letra, &#34;&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      switch(letra[0]){ 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //Direção
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        case &#39;D&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        case &#39;d&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          if(comando[0]==&#39;0&#39;){SerialBT.println(&#34;mudei direção pra 0&#34;);direcao=0;}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          else if(comando[0]==&#39;1&#39;){SerialBT.println(&#34;mudei direção pra 1&#34;); direcao=1;}   
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          else{SerialBT.println(&#34;ERRO2&#34;);}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          SerialBT.print(&#34;dir = &#34;); SerialBT.println(direcao);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          digitalWrite(pin_dir, direcao);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //Enable
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        case &#39;E&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        case &#39;e&#39; :
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          if(comando[0]==&#39;0&#39;){enable=0;}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          else if(comando[0]==&#39;1&#39;){enable=1;}   
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          else{SerialBT.println(&#34;ERRO3&#34;);}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          digitalWrite(pin_ena, enable);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          SerialBT.print(&#34;ena = &#34;); SerialBT.println(enable);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //Periodo em us
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        case &#39;P&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        case &#39;p&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          periodo=comando.toInt();  //forçar que o numero seja par
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          SerialBT.print(&#34;periodo (us) = &#34;); SerialBT.println(periodo);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //Numero de passos (Steps)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        case &#39;S&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        case &#39;s&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          if(comando[0]==&#39;.&#39;){SerialBT.println(&#34;Ficará ligado até comando stop&#34;); step=1; stay=1;}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          else{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            step=comando.toInt();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            SerialBT.print(&#34;step = &#34;);   SerialBT.println(step);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //Angulo de rotação em graus
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        case &#39;A&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        case &#39;a&#39;:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          SerialBT.print(&#34;angulo = &#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          if(comando[0]==&#39;-&#39;){ang_neg=1; direcao=0; comando.replace(&#34;-&#34;, &#34;&#34;);SerialBT.print(&#34;-&#34;);}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          else{ang_neg=0; direcao=1; SerialBT.print(&#34;+&#34;);}     
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          digitalWrite(pin_dir, direcao);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          angulo=comando.toInt(); 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          step=angulo*(pul_rev)/360;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          SerialBT.println(angulo);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        default:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          SerialBT.println(&#34;ERRO4&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      if(periodo&lt;5){periodo=6;SerialBT.println(&#34;ERRO5&#34;); SerialBT.println(&#34;OBS: Periodo mínimo = 5us (fmax=200kHz). Periodo setado para 6us&#34;);}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      else{SerialBT.println(&#34;frequencia dentro da permitida&gt;5us&#34;);}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      SerialBT.print(&#34;\nperiodo (us)= &#34;);  SerialBT.println(periodo);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      SerialBT.print(&#34;step = &#34;);  SerialBT.println(step);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      SerialBT.print(&#34;direcao = &#34;);  SerialBT.println(direcao);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      SerialBT.print(&#34;enable = &#34;);  SerialBT.println(enable);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      if(enable){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        SerialBT.println(&#34;Iniciado&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        for(int i=0; i&lt;step; i++){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          pulso = !pulso;                                    //inverte o estado da variável
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          digitalWrite(pin_pul, pulso);                      //atribui o novo estado à porta
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          delayMicroseconds(((   periodo/2  )*2)/2);         //tempo em alta do pulso (divide por 2 e multiplica por 2 pra ter certeza q vai ser inteiro)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          pulso = !pulso;                                    //inverte o estado da variável
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          digitalWrite(pin_pul, pulso);                      //atribui o novo estado à porta
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          delayMicroseconds(((   periodo/2  )*2)/2);         //tempo em baixa do pulso (divide por 2 e multiplica por 2 pra ter certeza q vai ser inteiro)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          if(stay){i--;}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          if (SerialBT.available()) {                        // Verifica se há dados disponíveis na conexão Bluetooth
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            comando= SerialBT.readStringUntil(&#39;\n&#39;);         // Lê o comando enviado pelo dispositivo remoto
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            comando.replace(&#34;\n&#34;, &#34;&#34;);                       // Remove o caractere &#39;\n&#39; da string
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            if(comando==&#34;stop&#34;){SerialBT.println(&#34;Forçada parada&#34;); i=step;stay=0;}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        enable=0;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        //se o angulo foi colocado como negativo, é preciso corrigir o sentido de giro apos comando
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        if(ang_neg){direcao=1; ang_neg=0;digitalWrite(pin_dir, direcao);SerialBT.println(&#34;Angulo negativo, direçao resetada&#34;);}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        SerialBT.println(&#34;Comando recebido: &#34; + comando);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        SerialBT.println(&#34;\nEnvie um comando&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // Adicione aqui qualquer outra lógica relacionada à tarefa Bluetooth
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    vTaskDelay(100 / portTICK_PERIOD_MS);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void TaskSerialCode(void *pvParameters) {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  while (1) {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Serial.println(&#34;oi mundo&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // Adicione aqui qualquer outra lógica relacionada à tarefa Serial
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    vTaskDelay(1000 / portTICK_PERIOD_MS);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void loop() {}
</span></span></code></pre></td></tr></table></div></div><blockquote class=attention-callout><p>OBS: Observe que a função de loop é deixada em branco, pois o esboço usa uma interrupção para notificar o Arduino sempre que uma mensagem válida é recebida e carregada em um dos buffers de recebimento.</p></blockquote><a href=#4-bibliografia><h1 id=4-bibliografia><span class=hanchor arialabel=Anchor># </span>4. Bibliografia</h1></a><p>(1)
<a href=https://www.fernandok.com/ rel=noopener>Dados motor de passo NEMA 34</a>
(2) [Sinalização erro LED HSS86](
<a href=https://www.cnczone.com/forums/servo-motors-drives/356990-software.html rel=noopener>HSS86 and 2HSS86H Closed Loop Drivers (cnczone.com)</a>)
(3)
<a href=https://www.fernandok.com/2018/07/protocolo-can-yes-we-can.html rel=noopener>Código CAN na ESP32 usando SN65HVD230</a>
(4)
<a href="https://www.youtube.com/watch?v=2x_IKvZJIPQ" rel=noopener>Uso software HSS86</a>
(5)
<a href=https://easytromlabs.com/arduino/arduino-lab-09-leitura-de-um-encoder-industrial-heidenhain-com-o-arduino/ rel=noopener>Projeto encoder com arduino</a>
(6) [Uso de interrupções na ESP32](
<a href=https://www.makerhero.com/blog/uso-de-interrupcoes-externas-com-esp32/ rel=noopener>Uso de interrupções externas com ESP32 - MakerHero</a>
(7)
<a href=http://www.alexag.com.br/Artigos/SAE2002.pdf rel=noopener>Introdução geral sobre rede CAN</a>
(8)
<a href=https://lastminuteengineers.com/mcp2515-can-module-arduino-tutorial/ rel=noopener>Transceiver MCP2515 com Arduino</a>
(9)
<a href=https://dewesoft.com/blog/what-is-can-bus rel=noopener>Tipos de CAN (low speed, high speed and FD)</a></p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://formula-e-siara.github.io/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Criado por Eduardo Balbino usando <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://formula-e-siara.github.io/>Home</a></li><li><a href=https://instagr.am/edubalbinoo>Instagram</a></li><li><a href=https://github.com/EduBalbino>Github</a></li></ul></footer></div></div></body></html>