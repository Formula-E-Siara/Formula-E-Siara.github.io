{"/":{"title":"PÃ¡gina inicial","content":"\nTentativa de criar uma [Knowledge Base](https://pt.wikipedia.org/wiki/Base_de_conhecimento) para o projeto FÃ³rmula-E SiarÃ¡ da Universidade Federal do CearÃ¡.\n\nObjetivos:\n\n1. Criar um Ãºnico local com uma verdade absoluta. Onde todos os membros podem consultar e, claro, corrigir.\n2. Promover um ponta-pÃ© inicial para os membros recÃ©m-ingressantes.\n\n## Participe agora mesmo!\n\u003e ğŸŒ [PÃ¡gina Inicial FÃ³rmula-E SiarÃ¡](FESiarÃ¡.md) \u003cbr/\u003e\n\u003e ğŸ“š [\"Como realizar modificaÃ§Ãµes na Wiki?\"](Como%20Realizar%20ModificaÃ§Ãµes.md) \u003cbr/\u003e\n","lastmodified":"2023-06-15T12:59:49.387182869Z","tags":null},"/Como-Realizar-Modifica%C3%A7%C3%B5es":{"title":"Modificar a Wiki","content":"\n\u003e[!INFO] NÃ£o Ã© simples\n\u003e\nMas tambÃ©m nÃ£o Ã© difÃ­cil.\n\n# Setup do GitHub\nO GitHub do FÃ³rmula-E SiarÃ¡ possui total acesso aos arquivos que compÃµem o site. Portanto, o primeiro passo deve ser fazer o login no mesmo.\n\n## [GitHub Desktop](https://desktop.github.com/)\nAlÃ©m do acesso ao GitHub pelo navegador, torna-se necessÃ¡rio a instalaÃ§Ã£o do GitHub Desktop para a atualizaÃ§Ã£o dos arquivos da Wiki.\n\nApÃ³s [baixar o GitHub Desktop](https://desktop.github.com/), Ã© necessÃ¡rio realizar a clonagem do repositÃ³rio:\n\n![](content/images/tutorial_github-desktop-tut1.png)\n\n![](content/images/tutorial_github-desktop-tut2.png)\n\n![](content/images/tutorial_github-desktop-tut3.png)\n\n# [Obsidian](http://obsidian.md)\n\nObsidian Ã© a melhor forma de realizar alteraÃ§Ãµes na Wiki, por jÃ¡ podermos ter uma prÃ©via de como a pÃ¡gina se tornarÃ¡. Entretanto, se vocÃª estiver se sentindo **valente** pode atÃ© mesmo realizar as modificaÃ§Ãµes nos arquivos ```.md``` pelo navegador ou Notepad.\n\nApÃ³s [baixar e instalar o Obsidian](https://obsidian.md/download), basta abrir um _vault_ na mesma pasta donde o repositÃ³rio foi clonado, com essa opÃ§Ã£o:\n\n![](content/images/tutorial_obsidian.png)\n\nCom isso, a estrutura da wiki estarÃ¡ de livre alteraÃ§Ã£o. Tome cuidado e nÃ£o faÃ§a besteiras! ğŸ˜€\n\n\n\u003e[!done] ParabÃ©ns!\n\u003e\nVocÃª estÃ¡ preparado para fazer alteraÃ§Ãµes relevantes Ã  equipe do FÃ³rmula-e SiarÃ¡! \n\n","lastmodified":"2023-06-15T12:59:49.383182893Z","tags":null},"/Dire%C3%A7%C3%A3o":{"title":"DireÃ§Ã£o","content":"\n\u003e[!tip] NÃ£o repare a bagunÃ§a, esse tÃ³pico ainda ta sendo organizado . . ...ğŸŒ\n\n\n![](content/images/tutorial_github-desktop-tut1.png)\n\n# 1. Acionamento motor por BT (HSS86)\n\n## 1.1. Motor de passo\n\n![](content/images/direcao_motor_driver.png)\n\nO motor utilizado para o projeto da direÃ§Ã£o elÃ©trica serÃ¡ o Tecmaf 34080 ([TMA.ES 34080](https://tecmaf.com.br/wp-content/uploads/2020/07/TMA.ES_.34080.pdf)), motor de passo bipolar com forÃ§a de 8 Nm, tal que cada passo equivale a um Ã¢ngulo de 1,8Â°Â± 5%. Algumas informaÃ§Ãµes sobre o motor:\n\n![](content/images/direcao_motor.png)\n\nO acionamento do motor estÃ¡ sendo feito com o apoio do driver dedicado ([HSS86](https://www.jbcnc.se/images/datasheets/HSS86.pdf)). O driver permite muitas funcionalidades Ãºteis, entre elas:\n\n-Â Â Â Â Â Â  Controle em malha fechada do motor que nÃ£o permite a perda de passo;\n-Â Â Â Â Â Â  Melhoria na performance em alta velocidade e alto torque;\n-Â Â Â Â Â Â  Ajuste automÃ¡tico de corrente baseado na carga de trabalho reduzindo o aquecimento;\n-Â Â Â Â Â Â  FrequÃªncia de resposta de pulso de 200 kHz;\n-Â Â Â Â Â Â  Possibilidade de escolha entre 16 micropassos (em escala de 400 a 51200 crosteps/rev) atravÃ©s das chaves fÃ­sicas na lateral do driver.\n-Â Â Â Â Â Â  ProteÃ§Ã£o contra sobrecorrente, sobretensÃ£o e diferenÃ§a de posiÃ§Ã£o.\n\n### 1.1.1. Diagrama de conexÃ£o\n\n![](content/images/direcao_esquema_hss86.png)\n\n### 1.1.2. Fios encoder motor\n\n![](content/images/direcao_db15_cores.png)\n\n### 1.1.3. ConexÃ£o encoder com driver HSS86\n\n![](content/images/direcao_conexao_encoder_hss86.png)\n\nÂ \n## 1.2. Hybrid Servo Driver (TMA DES HSS86)\n\n### 1.2.1. Luz seguranÃ§a\n\n![](content/images/direcao_luz_seg_hss86.png)\n\n### 1.2.2. ConfiguraÃ§Ã£o dos switches\n\nUsaremos configuraÃ§Ã£o default. Para acionamento do motor nÃ£o precisa tanta precisÃ£o\n\n![](content/images/direcao_microstep.png)\n\nou seja, todas as chaves devem ficar em on\n\n### 1.2.3. Controlador\n\n\u003e[!attention] ObservaÃ§Ã£o importante: Ligar o motor e driver com cabo desconectado poderÃ¡ danificar o driver e o encoder\n\nEstaremos usando o arduino que tem tensÃ£o de sinal de 5V logo nÃ£o precisa dos resistores conforme tabela abaixo. Para teste com esp (prÃ³ximo tÃ³pico), usaremos um optacoplador ligado aos pinos de saÃ­da, assim escolhemos a resistÃªncia de 2,2k pois usaremos 24V para dar maior margem para caso haja queda de tensÃ£o (checar diagrama 1.1.1.)\n\n![](content/images/direcao_pinos_controle_hss86.png)\n\n#### Pinos (HSS86)\n-Â Â Â Â Â Â  ENA (Enable): HIGH habilita o motor (considerando acionamento em HIGH conforme diagrama do datasheet do HSS86)\n-Â Â Â Â Â Â  DIR (Direction): HIGH horÃ¡rio/ LOW anti horÃ¡rio.\n-Â Â Â Â Â Â  PUL (Pulse): Esta Ã© a entrada de pulso do HSS86. Quando um pulso de sinal lÃ³gico alto Ã© aplicado a essa entrada, o motor avanÃ§a um passo ou uma posiÃ§Ã£o. O nÃºmero de pulsos necessÃ¡rios para um movimento completo depende das caracterÃ­sticas do motor.\n\n#### CÃ³digo (ESP32)\n\n````\nconst int pin_ena = 2; //habilita o motor\n\nconst int pin_dir = 3; //determina a direÃ§Ã£o\n\nconst int pin_pul = 4; //executa um passo\n\nint periodo = 1000; // micro segundos\n\nint step = 5; //Conta 400 pulsos\n\nboolean pulso = LOW; //estado do pulso\n\n/*Para saber a velocidade e o quanto o motor vai girar defina qual a configuraÃ§Ã£o\n\ndo \"divisor\" driver, 400 pulso/rev, 800pulso/rev 1600pulso/rev e etc\n\nA velocidade serÃ¡ freq/divisor, onde freq= 1/periodo\n\nEX: divisor default=400; periodo= 500us; freq=1/periodo= 1kHz\n\nResulta em 1000(pulso/s)/400(pulso/rev)=2.5 rev/s e 2.5 rev/s = 150 rpm\n\n- Se por exemplo step=400, sera executado 400 passos com o divisor fica\n\nstep/divisor=400(pulsos)/400(pulso/rev) que resulta em 1 rev.\n\n- Se sao 400 pulsos com velocidade 2.5 rev/s o tempo de 1 volta serÃ¡ de 1rev/2.5 0.4 segundos\n\n*/\n\nvoid setup(){\n\nÂ  pinMode(pin_ena, OUTPUT);\n\nÂ  pinMode(pin_dir, OUTPUT);\n\nÂ  pinMode(pin_pul, OUTPUT);\n\nÂ  digitalWrite(pin_ena, HIGH); //habilita em high, ligando portas positivas em high\n\nÂ  digitalWrite(pin_dir, HIGH); // low ANTIHORARIO / high HORARIO\n\nÂ  digitalWrite(pin_pul, LOW); //borda de decida\n\n}\n\nvoid loop(){\n\nÂ  delay(1000);\n\nÂ  for(int i=0; i\u003cstep; i++){\n\nÂ Â Â  pulso = !pulso; //inverte o estado da variÃ¡vel\n\nÂ Â Â  digitalWrite(pin_pul, pulso); //atribui o novo estado Ã  porta\n\nÂ Â Â  delayMicroseconds(periodo*1000/2); //tempo em alta do pulso\n\nÂ Â Â  pulso = !pulso; //inverte o estado da variÃ¡vel\n\nÂ Â Â  digitalWrite(pin_pul, pulso); //atribui o novo estado Ã  porta\n\nÂ Â Â  delayMicroseconds(periodo*1000/2); //tempo em baixa do pulso\n\nÂ  }\n\n}\n\n````\n\n#### Error\n\n![](content/images/direcao_error.png)\n## 1.3. Controlando por celular\n\nCelular(bluetooth) â†’ ESP â†’ optoacoplador â†’ driver HSS86\n\n### 1.3.1. ESP (portas BT)\n\n![](content/images/direcao_pinout_esp32.png)\n### 1.3.2. (SaÃ­da ESP)\n\nNecessÃ¡rio entre esp e driver pq saÃ­da esp Ã© de 3,3V\n\n#### Optacoplador TLP281-4\n\nPrÃ¡tico 4 entradas -\u003e 4 saÃ­das\n![](content/images/direcao_TLP281_4.png)\n\n![](content/images/direcao_TLP281-4_esquema.png)\n\n#### Conversor de NÃ­vel LÃ³gico 3.3V-5V Bidirecional - 2 Canais\n\nSugestÃ£o do professor, mas nÃ£o achamos no lab\n\n![](content/images/direcao_conversor_nivel_logico.png)\n\n#### Optacoplador HCPL-3120\n\ntinhamos sobrando no lab\n\n![](content/images/direcao_HCPL_3120.png)\n\n\u003e[!attention] Ã‰ necessÃ¡rio uso de um capacitor de bypass de 0,1 Î¼F entre os pinos 5 e 8\n\nPor datasheet do opta, temos:\n\n![](content/images/direcao_HCPL_3120_datasheet.png)\n\n##### Input\n\nA tensÃ£o de entrada serÃ¡ da ESP32 que Ã© de 3,3V, entÃ£o o resistor de entrada deve ser 330Î© (Î©min=3,3V/16mA=206Î©)\n\n##### Output\n\n\u003e[!attention] Ã‰ necessÃ¡rio se atentar Ã  necessidade de resistÃªncia entre o controlador e o driver de acordo com a tensÃ£o de controle utilizada.\nPelo datasheet, temos:\n![](content/images/direcao_resistencia_hss86.png)\n\nUsaremos alimentaÃ§Ã£o de saÃ­da em 24V (tem q estar entre 15 e 30V e o datasheet do hss dÃ¡ opÃ§Ã£o de 5V, 12V e 24V). Assim, lembrando pelo diagrama 1.1.1. e tabela 1.2.3. precisamos usar resistÃªncia de aproximamente 2k, usaremos 2k2 Î©\n\n### 1.3.4. (AlimentaÃ§Ã£o ESP)\n\nA alimentaÃ§Ã£o da esp pode ser feita pelo prÃ³prio conector USB (5,0V) ou entÃ£o atravÃ©s do pino 5V ou VIN , com uma alimentaÃ§Ã£o regulada de 5,0V\n\n#### Regulador KA7805\n\n![](content/images/direcao_KA7805.png)\n\n![](content/images/direcao_KA7805_data1.png)\n\n![](content/images/direcao_KA7805_data2.png)\n\n### 1.3.5. Aplicativo para controlar pelo celular\n\n#### Aplicativo 1: SÃ³ terminal Serial\n\n![](content/images/direcao_app1.jpg)\n\n![](content/images/direcao_app1_example.jpg)\n\n##### CÃ³digo acionamento (v1)\n\n````\n#include \"BluetoothSerial.h\"\n\nconst int ena = 33; //habilita o motor\n\nconst int dir = 32; //determina a direÃ§Ã£o\n\nconst int pul = 3; //executa um passo\n\nString comando;\n\nint periodo = 500; // em ms, faixa sugerida de 100 a 2000 (obs colocar numero par)\n\nint step = 4000; //Conta x pulsos\n\nboolean pulso = LOW; //estado inicial do pulso\n\nint pul_rev;\n\nint tempo;\n\nint angulo;\n\nint flag=0;\n\nString letra;\n\nBluetoothSerial SerialBT;\n\nvoid setup() {\n\nÂ  Serial.begin(9600); // Inicializa a porta serial para depuraÃ§Ã£o\n\nÂ  pinMode(ena, OUTPUT);\n\nÂ  pinMode(dir, OUTPUT);\n\nÂ  pinMode(pul, OUTPUT);\n\nÂ  digitalWrite(ena, HIGH); //habilita em high, ligando portas positivas em high\n\nÂ  digitalWrite(pul, LOW); //borda de decida\n\nÂ  SerialBT.begin(\"Controle remoto\"); // Inicializa a comunicaÃ§Ã£o Bluetooth\n\n}\n\nvoid loop() {\n\nÂ  delay(500);\n\nÂ  while(!flag){\n\nÂ Â Â  SerialBT.println(\"Informe valor pul_rev definido nas chaves do HSS86\");\n\nÂ Â Â  delay(5000);\n\nÂ Â Â  if (SerialBT.available()) { // Verifica se hÃ¡ dados disponÃ­veis na conexÃ£o Bluetooth\n\nÂ Â Â Â Â  comando=SerialBT.readStringUntil('\\n');\n\nÂ Â Â Â Â  pul_rev=comando.toInt();\n\nÂ Â Â Â Â  SerialBT.println(\"Envie um comando\");Â Â Â \n\nÂ Â Â Â Â  flag=1;\n\nÂ Â Â  }\n\nÂ  }\n\nÂ  if (SerialBT.available()) { // Verifica se hÃ¡ dados disponÃ­veis na conexÃ£o Bluetooth\n\nÂ Â Â  comando= SerialBT.readStringUntil('\\n');Â  // LÃª o comando enviado pelo dispositivo remoto\n\nÂ Â Â  comando.replace(\"\\n\", \"\"); // Remove o caractere '\\n' da string\n\nÂ Â Â  letra=comando[0];\n\nÂ Â Â  comando.replace(letra, \"\");\n\nÂ Â Â  switch(letra[0]){Â Â Â Â Â \n\nÂ Â Â Â Â  //DireÃ§Ã£o\n\nÂ Â Â Â Â  case 'D':\n\nÂ Â Â Â Â  case 'd':\n\nÂ Â Â Â Â Â Â  if(comando[0]=='0'){digitalWrite(dir, LOW); SerialBT.println(\"mudou dir pra 0\");}\n\nÂ Â Â Â Â Â Â  else if(comando[1]=='1'){digitalWrite(dir, HIGH); SerialBT.println(\"mudou dir pra 1\");Â Â  }Â Â Â \n\nÂ Â Â Â Â Â Â  else{SerialBT.println(\"Comando invÃ¡lido3\");}Â Â Â Â Â \n\nÂ Â Â  Â Â Â Â break;\n\nÂ Â Â Â Â  //Enable\n\nÂ Â Â Â Â  case 'E':Â Â Â \n\nÂ Â Â Â Â  case 'e' :\n\nÂ Â Â Â Â Â Â  if(comando[0]=='0'){digitalWrite(ena, LOW);SerialBT.println(\"mudou ena pra 0\");}\n\nÂ Â Â Â Â Â Â  else if(comando[1]=='1'){digitalWrite(ena, HIGH);SerialBT.println(\"mudou ena pra 1\");}Â Â Â \n\nÂ Â Â Â Â Â Â  else{SerialBT.println(\"Comando invÃ¡lido1\");}Â Â Â Â Â \n\nÂ Â Â Â Â Â Â  break;\n\nÂ Â Â Â Â  //Periodo em ms, faixa sugerida de 100 a 2000 (obs colocar numero par)\n\nÂ Â Â Â Â  case 'P':\n\nÂ Â Â Â Â  case 'p':\n\nÂ Â Â Â Â Â Â  periodo=comando.toInt();\n\nÂ Â Â Â Â Â Â  SerialBT.println(\"periodo alterado\");\n\nÂ Â Â Â Â Â Â  SerialBT.println(periodo);\n\nÂ Â Â Â Â Â Â  break;\n\nÂ Â Â Â Â  //Numero de passos (Steps)\n\nÂ Â Â Â Â  case 'S':\n\nÂ Â Â Â Â  case 's':Â Â Â \n\nÂ Â Â Â Â Â Â  step=comando.toInt();\n\nÂ Â Â Â Â Â Â  SerialBT.println(\"step alterado\");SerialBT.println(step);\n\nÂ Â Â Â Â Â Â  break;\n\nÂ Â Â Â Â  //Angulo de rotaÃ§Ã£o em graus\n\nÂ Â Â Â Â  case 'A':\n\nÂ Â Â Â Â  case 'a':Â Â Â Â Â Â Â Â Â \n\nÂ Â Â Â Â Â Â  angulo=comando.toInt();Â \n\nÂ Â Â Â Â Â Â  step=angulo*(pul_rev)/180;\n\nÂ Â Â Â Â Â Â  SerialBT.println(\"angulo alterado\");SerialBT.println(angulo);\n\nÂ Â Â Â Â Â Â  break;\n\nÂ Â Â Â Â  //Tempo de acionamento em ms\n\nÂ Â Â Â Â  case 'T':\n\nÂ Â Â Â Â  case 't':Â \n\nÂ Â Â Â Â Â Â  tempo=comando.toInt();\n\nÂ Â Â Â Â Â Â  SerialBT.println(\"tempo alterado\");SerialBT.println(tempo);\n\nÂ Â Â Â Â Â Â  step=tempo*1000/periodo;\n\nÂ Â Â Â Â Â Â  break;\n\nÂ Â Â Â Â  default:\n\nÂ Â Â Â Â Â Â  SerialBT.println(\"Comando invÃ¡lido2\");\n\nÂ Â Â Â Â Â Â  break;Â \n\nÂ Â Â Â Â  }\n\nÂ Â Â  }\n\nÂ  for(int i=0; i\u003c=step; i++){\n\nÂ Â Â  digitalWrite(pul, pulso); //atribui o novo estado Ã  porta\n\nÂ Â Â  delayMicroseconds(periodo/2); //tempo em alta do pulso\n\nÂ Â Â  pulso = !pulso; //inverte o estado da variÃ¡vel\n\nÂ Â Â  digitalWrite(pul, pulso); //atribui o novo estado Ã  porta\n\nÂ Â Â  delayMicroseconds(periodo/2); //tempo em baixa do pulso\n\nÂ  }\n\n}\n\n````\n\n##### CÃ³digo acionamento (v2)\n\n````\n#include \"BluetoothSerial.h\"\n\nBluetoothSerial SerialBT;\n\n//Definindo pinos\n\nconst int pin_ena = 15;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //habilita o motor\n\nconst int pin_dir = 5;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //determina a direÃ§Ã£o\n\nconst int pin_pul = 4;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //executa um passo\n\n//Variaveis para leitura mensagem bt\n\nString comando;\n\nString letra;\n\n//VariÃ¡veis para controle do motor\n\nboolean direcao = HIGH;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // low AH - high H\n\nboolean enable = LOW;\n\nvolatile boolean pulso = LOW;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //estado inicial do pulso (borda de decida)\n\nvolatile int step = 4000;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //Conta x pulsos\n\nvolatile unsigned long periodo = 6;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  /* microsegundos (periodo minimo)\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  Frequencia do driver 200kHz (ou seja, 1 pulso em 1/200k=0.005 ms=5us).\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  O ideal seria 2.5 (positivo e negativo), mas vamos trabalhar com margem*/\n\n//VariÃ¡veis para calculo/conversÃ£o\n\nvolatile int tempo;\n\nint angulo;\n\nint pul_rev;\n\n//Flags intermediarias\n\nint ang_neg=0;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //flag sinal angulo\n\nint flag=0;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  Â Â Â Â Â Â Â Â //flag valor pul_rev recebido\n\nint stay=0;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //flag comando permanecer ligado\n\nvoid setup(){\n\nÂ  Serial.begin(9600);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // Inicializa a porta serial para depuraÃ§Ã£o\n\nÂ  pinMode(pin_ena, OUTPUT);\n\nÂ  pinMode(pin_dir, OUTPUT);\n\nÂ  pinMode(pin_pul, OUTPUT);\n\nÂ  digitalWrite(pin_ena, enable);\n\nÂ  digitalWrite(pin_dir, direcao);\n\nÂ  digitalWrite(pin_pul, pulso);\n\nÂ  SerialBT.begin(\"Controle remoto\"); // Nome do dispositivo para comunicaÃ§Ã£o BT\n\n}\n\nvoid loop(){\n\nÂ  //Pro calculo de tempo e angulo precisa saber o valor de pul_rev (chaves do hss86)\n\nÂ  while(!flag){\n\nÂ Â Â  SerialBT.println(\"Informe valor pul_rev definido nas chaves do HSS86\");\n\nÂ Â Â  delay(5000);\n\nÂ Â Â  if (SerialBT.available()) { //Verifica se hÃ¡ dados disponÃ­veis na conexÃ£o Bluetooth\n\nÂ Â Â Â Â  comando=SerialBT.readStringUntil('\\n');\n\nÂ Â Â Â Â  pul_rev=comando.toInt();\n\nÂ Â Â Â Â  switch(pul_rev){\n\nÂ Â Â Â Â Â Â  case 400:Â Â  case 800:Â Â  case 1000:Â  case 1600:\n\nÂ Â Â Â Â Â Â  case 2000:Â  case 3200:Â  case 4000:Â  case 5000:\n\nÂ Â Â Â Â Â Â  case 6400:Â  case 8000:Â  case 10000: case 12800:\n\nÂ Â Â Â Â Â Â  case 20000: case 25600: case 40000: case 51200:\n\nÂ Â Â Â Â Â Â Â Â Â Â  SerialBT.print(\"Pul_rev = \");Â  SerialBT.println(pul_rev);\n\nÂ Â Â Â Â Â Â Â Â Â Â  SerialBT.println(\"Envie um comando\");\n\nÂ Â Â Â Â Â Â Â Â Â Â  flag=1;\n\nÂ Â Â Â Â Â Â  break;\n\nÂ Â Â Â Â Â Â  default:\n\nÂ Â Â Â Â Â Â Â Â  SerialBT.println(\"ERRO1. Obs: default=400\");\n\nÂ Â Â Â Â Â Â Â Â  break;\n\nÂ Â Â Â Â  }\n\nÂ Â Â  }\n\nÂ  }\n\nÂ  if (SerialBT.available()) {Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // Verifica se hÃ¡ dados disponÃ­veis na conexÃ£o Bluetooth\n\nÂ Â Â  //Tratar comando recebido\n\nÂ Â Â  comando= SerialBT.readStringUntil('\\n');Â  // LÃª o comando enviado pelo dispositivo remoto\n\nÂ Â Â  comando.replace(\"\\n\", \"\");Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // Remove o caractere '\\n' da string\n\nÂ Â Â  letra=comando[0];\n\nÂ Â Â  comando.replace(letra, \"\");\n\nÂ Â Â  switch(letra[0]){Â \n\nÂ Â Â Â Â  //DireÃ§Ã£o\n\nÂ Â Â Â Â  case 'D':\n\nÂ Â Â Â Â  case 'd':\n\nÂ Â Â Â Â Â Â  if(comando[0]=='0'){direcao=0;}\n\nÂ Â Â Â Â Â Â  else if(comando[0]=='1'){direcao=1;}Â Â Â \n\nÂ Â Â Â Â Â Â  else{SerialBT.println(\"\\nERRO2\\nValor de direÃ§Ã£o invalida\");}\n\nÂ Â Â Â Â Â Â  digitalWrite(pin_dir, direcao);\n\nÂ Â Â Â Â  break;\n\nÂ Â Â Â Â  //Enable\n\nÂ Â Â Â Â  case 'E':\n\nÂ Â Â Â Â  case 'e' :\n\nÂ Â Â Â Â Â Â  if(comando[0]=='0'){enable=0;}\n\nÂ Â Â Â Â Â Â  else if(comando[0]=='1'){enable=1;}Â Â Â \n\nÂ Â Â Â Â Â Â  else{SerialBT.println(\"\\nERRO3\\nValor de enable invalido\");}\n\nÂ Â Â Â Â Â Â  digitalWrite(pin_ena, enable);\n\nÂ Â Â Â Â  break;\n\nÂ Â Â Â Â  //Periodo em us\n\nÂ Â Â Â Â  case 'P':\n\nÂ Â Â Â Â  case 'p':\n\nÂ Â Â Â Â Â Â  periodo=comando.toInt();\n\nÂ Â Â Â Â  break;\n\nÂ Â Â Â Â  //Numero de passos (Steps)\n\nÂ Â Â Â Â  case 'S':\n\nÂ Â Â Â Â  case 's':\n\nÂ Â Â Â Â Â Â  if(comando[0]=='.'){SerialBT.println(\"Modo ligado atÃ© comando stop\"); step=1; stay=1;}\n\nÂ Â Â Â Â Â Â  else{step=comando.toInt();}\n\nÂ Â Â Â Â  break;\n\nÂ Â Â Â Â  //Angulo de rotaÃ§Ã£o em graus\n\nÂ Â Â Â Â  case 'A':\n\nÂ Â Â Â Â  case 'a':\n\nÂ Â Â Â Â Â Â  if(comando[0]=='-'){ang_neg=1; direcao=0; comando.replace(\"-\", \"\");}\n\nÂ Â Â Â Â Â Â  else{ang_neg=0; direcao=1;}Â Â Â Â Â \n\nÂ Â Â Â Â Â Â  digitalWrite(pin_dir, direcao);\n\nÂ Â Â Â Â Â Â  angulo=comando.toInt();Â \n\nÂ Â Â Â Â Â Â  step=angulo*(pul_rev)/360;\n\nÂ Â Â Â Â  break;\n\nÂ Â Â Â Â  /*\n\nÂ Â Â Â Â  NÃ£o consegui corrigir o tempo, quando envio o comando, a esp desconectaÂ Â Â Â Â \n\nÂ Â Â Â Â  //Tempo de acionamento em s\n\nÂ Â Â Â Â  case 'T':\n\nÂ Â Â Â Â  case 't':Â \n\nÂ Â Â Â Â Â Â  tempo=comando.toInt();\n\nÂ Â Â Â Â Â Â  periodo=tempo*1000000/step;\n\nÂ Â Â Â Â  break;\n\nÂ Â Â Â Â  */\n\nÂ Â Â Â Â  default:\n\nÂ Â Â Â Â Â Â  SerialBT.println(\"\\nERRO4\");\n\nÂ Â Â Â Â  break;\n\nÂ Â Â  }\n\nÂ Â Â  if(periodo\u003c5){periodo=6;SerialBT.println(\"\\nERRO5\\nOBS: Periodo mÃ­nimo = 5us (fmax=200kHz). Periodo setado para 6us\");}\n\nÂ Â Â  SerialBT.printf(\"\\nperiodo(us) = %i\\nstep = %i\\ndirecao = %i\\nenable =Â  %i\\n\",periodo,step,direcao,enable);\n\nÂ Â Â  if(enable){\n\nÂ Â Â Â Â  SerialBT.println(\"\\nIniciado\");\n\nÂ Â Â Â Â  for(int i=0; i\u003cstep; i++){\n\nÂ Â Â Â Â Â Â  pulso = !pulso;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //inverte o estado da variÃ¡vel\n\nÂ Â Â Â Â Â Â  digitalWrite(pin_pul, pulso);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //atribui o novo estado Ã  porta\n\nÂ Â Â Â Â Â Â  delayMicroseconds(((Â Â  periodo/2Â  )*2)/2);Â Â Â Â Â Â Â Â  //tempo em alta do pulso (divide por 2 e multiplica por 2 pra ter certeza q vai ser inteiro)\n\nÂ Â Â Â Â Â Â  pulso = !pulso;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â //inverte o estado da variÃ¡vel\n\nÂ Â Â Â Â Â Â  digitalWrite(pin_pul, pulso);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //atribui o novo estado Ã  porta\n\nÂ Â Â Â Â Â Â  delayMicroseconds(((Â Â  periodo/2Â  )*2)/2);Â Â Â Â Â Â Â Â  //tempo em baixa do pulso (divide por 2 e multiplica por 2 pra ter certeza q vai ser inteiro)\n\nÂ Â Â Â Â Â Â  if(stay){i--;}Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //Decrementa contador, mantem loop infinito\n\nÂ Â Â Â Â Â Â  if (SerialBT.available()) {Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // Verifica se hÃ¡ dados disponÃ­veis na conexÃ£o Bluetooth\n\nÂ Â Â Â Â Â Â Â Â  //tratamento comando recebido bt\n\nÂ Â Â Â Â Â Â Â Â  comando= SerialBT.readStringUntil('\\n');\n\nÂ Â Â Â Â Â Â Â Â  comando.replace(\"\\n\", \"\");\n\nÂ Â Â Â Â Â Â Â Â  if(comando==\"stop\"){SerialBT.println(\"ForÃ§ada parada\"); i=step;stay=0;}\n\nÂ Â Â Â Â Â Â  }\n\nÂ Â Â Â Â  }\n\nÂ Â Â Â Â  enable=0;\n\nÂ Â Â Â Â  //se o angulo foi colocado como negativo, Ã© preciso corrigir o sentido de giro apos comando\n\nÂ Â Â Â Â  if(ang_neg){direcao=1; ang_neg=0;digitalWrite(pin_dir, direcao);}\n\nÂ Â Â  }\n\nÂ Â Â  SerialBT.println(\"\\nEnvie um comando\");\n\nÂ  }\n\n}\n\n````\n\n#### Aplicativo 2: Controle remoto\n\n![](content/images/direcao_app2.png)\n\n![](content/images/direcao_app2_comandos.png)\n\nUsaremos:\n-Â Â Â Â Â Â  L (left)\n-Â Â Â Â Â Â  R (right)\n-Â Â Â Â Â Â  S (stop)\n-Â Â Â Â Â Â  0 - 9 + q (speed)\n-Â Â Â Â Â Â  D (close app)\n\n##### CÃ³digo acionamento (v3)\n\no valor pmin=166 foi obtido por estresse do motor em teste de bancada, maior velocidade para que nÃ£o perca o passo na velocidade mÃ¡xima (9)\n\n````\n#include \"BluetoothSerial.h\"\n\nBluetoothSerial SerialBT;\n\n//Definindo pinos\n\nconst int pin_ena = 15;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //habilita o motor\n\nconst int pin_dir = 2;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //determina a direÃ§Ã£o\n\nconst int pin_pul = 4;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //executa um passo\n\n//Variaveis para leitura mensagem bt\n\nString comando;\n\n//VariÃ¡veis para controle do motor\n\nboolean direcao = HIGH;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // low AH - high H\n\nboolean enable = LOW;\n\nint pmin=166;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //Para caso de pul_rev 400 (Experimental)\n\nint velocidade=0;\n\nvolatile boolean pulso = LOW;Â Â Â Â Â Â Â Â  Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â //estado inicial do pulso (borda de decida)\n\nvolatile unsigned long periodo = pmin;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  /* microsegundos (periodo minimo)\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  Frequencia do driver 200kHz (ou seja, 1 pulso em 1/200k=0.005 ms=5us).\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  O ideal seria 2.5 (positivo e negativo), mas vamos trabalhar com margem*/\n\nvoid setup(){\n\nÂ  Serial.begin(9600);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // Inicializa a porta serial para depuraÃ§Ã£o\n\nÂ  pinMode(pin_ena, OUTPUT);\n\nÂ  pinMode(pin_dir, OUTPUT);\n\nÂ  pinMode(pin_pul, OUTPUT);\n\nÂ  digitalWrite(pin_ena, enable);\n\nÂ  digitalWrite(pin_dir, direcao);\n\nÂ  digitalWrite(pin_pul, pulso);\n\nÂ  SerialBT.begin(\"Controle remoto\"); // Nome do dispositivo para comunicaÃ§Ã£o BT\n\n}\n\nvoid loop(){\n\nÂ  if (SerialBT.available()) {Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // Verifica se hÃ¡ dados disponÃ­veis na conexÃ£o Bluetooth\n\nÂ Â Â  //Tratar comando recebido\n\nÂ Â Â  comando= char(SerialBT.read());Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // LÃª o comando enviado pelo dispositivo remoto\n\nÂ Â Â  switch(comando[0]){Â \n\nÂ Â Â Â Â  //L (left)\n\nÂ Â Â Â Â  case 'L':\n\nÂ Â Â Â Â Â Â  enable=1;direcao=0;\n\nÂ Â Â Â Â Â Â  //Serial.print(comando);Serial.println(\" -\u003e d0\");\n\nÂ Â Â Â Â  break;\n\nÂ Â Â Â Â  //R (right)\n\nÂ Â Â Â Â  case 'R':\n\nÂ Â Â Â Â Â Â  enable=1;direcao=1;\n\nÂ Â Â Â Â Â Â  //Serial.print(comando);Serial.println(\" -\u003e d1\");\n\nÂ Â Â Â Â  break;\n\nÂ Â Â Â Â  //S(stop)\n\nÂ Â Â Â Â  case 'S':\n\nÂ Â Â Â Â  case 'D':\n\nÂ Â Â Â Â Â Â  enable=0;\n\nÂ Â Â Â Â Â Â  //Serial.print(comando);Serial.println(\" -\u003e e0\");\n\nÂ Â Â Â Â  break;\n\nÂ Â Â Â Â  //Speed\n\nÂ Â Â Â Â  case '0': case '1': case '2': case '3':\n\nÂ Â Â Â Â  case '4': case '5': case '6': case '7':\n\nÂ Â Â Â Â  case '8': case '9':\n\nÂ Â Â Â Â Â Â  velocidade=comando.toInt();\n\nÂ Â Â Â Â Â Â  periodo=pmin*(1+(10-velocidade)/2);\n\nÂ Â Â Â Â Â Â  //PA com razao sendo metade do periodo minimo\n\nÂ Â Â Â Â Â Â  //Serial.print(comando);Serial.printf(\" p%i\\n\",periodo);\n\nÂ Â Â Â Â  break;\n\nÂ Â Â Â Â  case 'q':\n\nÂ Â Â Â Â Â Â  velocidade=10;\n\nÂ Â Â Â Â Â Â  periodo=pmin*(1+(10-velocidade)/2);\n\nÂ Â Â Â Â Â Â  //PA com razao sendo metade do periodo minimo\n\nÂ Â Â Â Â Â Â  //Serial.print(comando);Serial.printf(\" p%i\\n\",periodo);\n\nÂ Â Â Â Â  break;\n\nÂ Â Â Â Â  default:\n\nÂ Â Â Â Â Â Â  Serial.println(\"\\nERRO4\");\n\nÂ Â Â Â Â  break;\n\nÂ Â Â  }\n\nÂ Â Â  digitalWrite(pin_ena, enable);\n\nÂ Â Â  digitalWrite(pin_dir, direcao);\n\nÂ Â Â  Serial.print(\" p\");Serial.print(periodo);\n\nÂ Â Â  Serial.print(\" d\");Serial.print(direcao);\n\nÂ Â Â  Serial.print(\" e\");Serial.println(enable);\n\nÂ Â Â  //Serial.printf(\"\\nperiodo(us) = %i\\nstep = %i\\ndirecao = %i\\nenable =Â  %i\\n\",periodo,step,direcao,enable);\n\nÂ Â Â  while(enable \u0026\u0026 comando[0]!='D' \u0026\u0026 comando[0]!='S'){\n\nÂ Â Â Â Â  pulso = !pulso;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //inverte o estado da variÃ¡vel\n\nÂ Â Â Â Â  digitalWrite(pin_pul, pulso);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //atribui o novo estado Ã  porta\n\nÂ Â Â Â Â  delayMicroseconds(((Â Â  periodo/2Â  )*2)/2);Â Â Â Â Â Â Â Â  //tempo em alta do pulso (divide por 2 e multiplica por 2 pra ter certeza q vai ser inteiro)\n\nÂ Â Â Â Â  pulso = !pulso;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //inverte o estado da variÃ¡vel\n\nÂ Â Â Â Â  digitalWrite(pin_pul, pulso);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //atribui o novo estado Ã  porta\n\nÂ Â Â Â Â  delayMicroseconds(((Â Â  periodo/2Â  )*2)/2);Â Â Â Â Â Â Â Â  //tempo em baixa do pulso (divide por 2 e multiplica por 2 pra ter certeza q vai ser inteiro)\n\nÂ Â Â Â Â  if (SerialBT.available()) {Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // Verifica se hÃ¡ dados disponÃ­veis na conexÃ£o Bluetooth\n\nÂ Â Â Â Â Â Â  comando= char(SerialBT.read());\n\nÂ Â Â Â Â  }\n\nÂ Â Â  }\n\nÂ  }\n\n}\n\n````\n\n# 2. Controle remoto\n\n## 2.1. Possibilidades\n\n1. Bluetooth: O Bluetooth Ã© uma tecnologia sem fio de curto alcance que Ã© amplamente utilizada em dispositivos mÃ³veis, como smartphones e fones de ouvido. Ã‰ relativamente fÃ¡cil de configurar e oferece uma boa taxa de transferÃªncia de dados para distÃ¢ncias de atÃ© 10 metros em ambientes internos.\n2. WiFi: O WiFi Ã© um protocolo de comunicaÃ§Ã£o sem fio de mÃ©dio alcance que Ã© amplamente utilizado em redes domÃ©sticas e empresariais. Ã‰ mais complexo de configurar do que o Bluetooth, mas oferece taxas de transferÃªncia de dados mais altas e uma cobertura de alcance mais ampla para distÃ¢ncias de atÃ© cerca de 50 metros em ambientes internos.\n3. Zigbee: Zigbee Ã© um protocolo de comunicaÃ§Ã£o sem fio de curto alcance que Ã© frequentemente usado em sistemas de automaÃ§Ã£o residencial e industrial. Ã‰ especialmente adequado para aplicaÃ§Ãµes que exigem baixo consumo de energia e comunicaÃ§Ã£o confiÃ¡vel para distÃ¢ncias de atÃ© cerca de 10 metros.\n4. LoRa: LoRa Ã© um protocolo de comunicaÃ§Ã£o de longo alcance que Ã© adequado para aplicaÃ§Ãµes que exigem cobertura em grandes Ã¡reas. Embora a distÃ¢ncia mÃ¡xima de comunicaÃ§Ã£o possa ser superior a vÃ¡rios quilÃ´metros em condiÃ§Ãµes ideais, a taxa de transferÃªncia de dados Ã© relativamente baixa. Portanto, Ã© mais adequado para aplicaÃ§Ãµes que exigem comunicaÃ§Ã£o de baixa taxa de dados, como monitoramento de sensores remotos.\n\n### 2.1.1. Phantom 4\n\n![](content/images/direcao_phantom4.png)\n\nO controle remoto do Phantom 4 utiliza uma tecnologia de comunicaÃ§Ã£o proprietÃ¡ria da DJI, chamada de Lightbridge, que nÃ£o Ã© diretamente compatÃ­vel com microcontroladores convencionais, como o Arduino\n\n### 2.1.2. Arduino + mÃ³dulo WiFi\n\n![](content/images/Arduino_WiFi.png)\n\n![](content/images/Arduino_WiFi2.png)\n\n### 2.1.3. ESP para Raspberry (SPI)\n\nUma opÃ§Ã£o seria a leitura do controle remotoÂ  feita pela raspberry (controlador) tal que esta envie os sinais para esp (perifÃ©rico) que controlarÃ¡ o driver\n\n#### Estudando ComunicaÃ§Ã£o SPI\n\nNa comunicaÃ§Ã£o serial sÃ­ncrona introduzimos o conceito de mestre - escravo (controlador - perifÃ©rico), com apenas um controlador. Ou seja, um mesmo sensor (perifÃ©rico) nÃ£o pode estar em duas redes distintas, cada uma com um mestre diferente.\n\nAlÃ©m disso, os barramentos sÃ£o unidirecionais, ou seja, os sinais sÃ£o definidos somente como enviado ou somente como recebido. Mas Ã© possÃ­vel envio e recebimento de sinal de forma simultÃ¢nea (por barramentos diferentes)\n\n![](content/images/direcao_SPI.png)\n\n![](content/images/direcao_SPI2.png)\n\nPossÃ­vel atingir velocidades maiores de comunicaÃ§Ã£o porque hÃ¡ pouca deformaÃ§Ã£o do sinal utilizando dois canais separados\n\n##### Exemplo ligaÃ§Ã£o\n\n![](content/images/direcao_SPI3.png)\n\nNo SS, o dispositivo Ã© selecionado quando este pino se encontra em nÃ­vel baixo\nMISO: serial data out (SDO)\nMOSI: serial data in (SDI)\n\n![](content/images/direcao_SPI4.png)\n\n![](content/images/direcao_SPI5.png)\n\n#### ESP32 (portas spi)\n\n![](content/images/direcao_SPI6.png)\n\n![](content/images/direcao_SPI7.png)\n\nSP0 and SP1 are used internally to communicate with the built-in flash memory, and you should not use them for other tasks.\n\n### !2.1.4. ESP para Raspberry (CAN)\n\n#### Protocolo CAN\n\n##### CaracterÃ­sticas geraisÂ Â Â Â Â Â Â Â Â Â Â \n\n![](content/images/direcao_CAN.png)\n\nProtocolo CAN (Controller Area Network) Ã© um protocolo de comunicaÃ§Ã£o serial simultÃ¢nea:\n-Â Â Â Â Â Â  transmite dados a uma taxa de atÃ© 1 Mbps em barramentos de atÃ© 40 metros;\n-Â Â Â Â Â Â  sÃ­ncrono: sincronizaÃ§Ã£o no inÃ­cio de cada mensagem enviada ao barramento;\n-Â Â Â Â Â Â  multicast: todas as mensagens sÃ£o recebidas por todos os mÃ³dulos da rede;\n-Â Â Â Â Â Â  multi-mestre: todos mÃ³dulos podem ser mestre ou escravo em determinado momento;\n-Â Â Â Â Â Â  Suporta atÃ© 120 nÃ³s por barramentos;\n-Â Â Â Â Â Â  CSMA/CD with NDA: caso duas mensagens sejam enviadas ao barramento ao mesmo instante, o mÃ³dulo de menor prioridade cessarÃ¡ sua transmissÃ£o e o de maior continuarÃ¡ enviando sua mensagem, sem ter que reiniciÃ¡-la;\n-Â Â Â Â Â Â  NRZ (Non Return to Zero): cada bit transmitido representa efetivamente um dado;\n-Â Â Â Â Â Â  Protocolo regulado: ISO 11898\n-Â Â Â Â Â Â  A velocidade de transmissÃ£o dos dados Ã© proporcional ao comprimento do barramento;\n\n![](content/images/direcao_CAN2.png)\n\nO protocolo foi desenvolvido pela BOSCH\n\n##### ConfiguraÃ§Ã£o dos fios\n\nHÃ¡ trÃªs formas de construir o barramento (bus):\n-Â Â Â Â Â Â  2 fios (dados: CAN H - high e CAN L - low),\n-Â Â Â Â Â Â  4 fios (dado + VCC e GND, para alimentaÃ§Ã£o dos blocos subsequentes)\n-Â Â Â Â Â Â  1 fio (Somente 1 fio de dado: CAN).\n\nO barramento Ã© classificado como Par TranÃ§ado Diferencial (para 2 e 4 fios): os dados sÃ£o interpretados pela anÃ¡lise da diferenÃ§a de potencial entre os fios CAN H e CAN L, por isso nÃ£o necessita blindagem (pois, caso haja efeito de campo externo, afetarÃ¡ ambos os sinais)\n\nPara velocidades de comunicaÃ§Ã£o acima de 250 kbit/s, Ã© recomendado cabo em par tranÃ§ado para a minimizaÃ§Ã£o de ruÃ­dos. Ã‰ recomendado um resistor externo de 120 Î©/0,25 W para a rede CAN. A secÃ§Ã£o transversal de cada um dos fios deve ser de no mÃ­nimo 0,35mmÂ²\n\n##### Formato dos dados\n\nOs dados sÃ£o representados por bits recessivos e dominantes. O bit zero Ã© dominante.Â  ApÃ³s enviar um bit, cada mÃ³dulo analisa o barramento e verifica se outro mÃ³dulo na rede o sobrescreveu.\n\n![](content/images/direcao_CAN3.png)\n\n##### Formatos de mensagem:\n\n-Â Â Â Â Â Â  CAN 2.0A (padrÃ£o): Mensagens com identificador de 11 bits, atÃ© 2048 mensagens\n\n![](content/images/direcao_CAN4.png)\n\n![](content/images/direcao_CAN5.png)\n\n-Â Â Â Â Â Â  CAN 2.0B (estendido): identificador de 29 bits, atÃ©Â  5,3*10â¶ de mensagens, entretanto hÃ¡ aumento no tempo de transmissÃ£o de cada mensagem\n\n![](content/images/direcao_CAN6.png)\n\n![](content/images/direcao_CAN7.png)\n\n##### Tipos de mensagens:\n\n-Â Â Â Â Â Â  Frame de Dados: ContÃ©m os dados do emissor para o(s) receptor(es);\n\n![](content/images/direcao_CAN8.png)\n\n-Â Â Â Â Â Â  Frame Remota: Ã‰ uma solicitaÃ§Ã£o de dados partindo de um dos nÃ³s;\n\n![](content/images/direcao_CAN9.png)\n\n-Â Â Â Â Â Â  Frame de Erro: Ã‰ um frame enviado por qualquer um dos nÃ³s ao identificar um erro no barramento e pode ser detectado por todos os nÃ³s;\n\n![](content/images/direcao_CAN10.png)\n-Â Â Â Â Â Â  Frame de sobrecarga: Serve para retardar o trÃ¡fego no barramento devido Ã  sobrecarga de dados ou atraso em um ou mais nÃ³s.\n\n![](content/images/direcao_CAN11.png)\n\n##### Transceiver (MCP2515 -Â  Controlador CAN Stand-Alone com Interface SPI)\n\n![](content/images/direcao_MCP2515.png)\n\nPor que usar MCP2515 se a ESP32 ja tem uma porta CAN interna? Existem aplicaÃ§Ãµes que requerem mais de uma porta CAN, e o Ãºnico recurso do ESP32 aplicÃ¡vel para isso Ã© a interface SPI. Na verdade, hipoteticamente, vocÃª pode adicionar atÃ© seis portas CAN controladas por SPI ao ESP32\n\n![](content/images/direcao_MCP2515_pinout.png)\n\n# 3. Encoder\n\n![](content/images/direcao_encoder.png)\n\n## 3.1. Possibilidades\n\n### 3.1.1. Encoder externo\n\n(Pegar os dados diretamente do motor)\n\nteria que fazer uma reduÃ§Ã£o com faixas escuras delimitadas para leitura por esse sensor. Ele envia luz e atua conforme a reflexÃ£o dela dada a sua reflexÃ£o.\n\n![](content/images/direcao_encoder2.png)\n\nFunciona como um amplificador. Mudando as resistÃªncias, altera a faixa que ele considera alta(3,3V) e baixa(0V). Assim, alteramos a sensibilidade do sensor (luz)\n\n![](content/images/direcao_encoder3.png)\n\n### 3.1.2. Software HSS86\n\n(Pegar dos dados a partir do driver HSS86)\n\n![](content/images/direcao_soft_HSS86.png)\n\n![](content/images/direcao_soft_HSS86_2.png)\n\n![](content/images/direcao_soft_HSS86_3.png)\n\n![](content/images/direcao_soft_HSS86_4.png)\n\n### 3.1.3. Encoder do prÃ³prio motor\n\n#### Leitura encoder\n\nTestes para p=1000us, pelo osciloscÃ³pio temos que o perÃ­odo do motor equivale a 400us para essa aplicaÃ§Ã£o.\n\n![](content/images/direcao_teste_encoder.jpg)\nSinais ea+ e eb+ sÃ£o defasados em 90 (sentido horÃ¡rio d1)\n\n![](content/images/direcao_teste_encoder2.jpg)\nSinais ea+ e eb+ sÃ£o defasados em 90 (sentido anti horÃ¡rio d0)\n\n![](content/images/direcao_teste_encoder3.jpg)\nSinais ea+ e ea- sÃ£o opostos\n\n#### ESP32 (AttachInterrupt)\n\n![](content/images/direcao_pinout_attach.png)\n\nfunÃ§Ã£o _attachInterrupt_, cujo protÃ³tipo Ã© _attachInterrupt(GPIOPin, ISR, Mode)_. Onde:\n\nâ—Â Â Â Â  **GPIOPin:** nÃºmero do GPIO que quer monitorar utilizando interrupÃ§Ã£o externa;\n\nâ—Â Â Â Â  **ISR:** nome da funÃ§Ã£o a ser chamada na hora de tratar a interrupÃ§Ã£o;\n\nâ—Â Â Â Â  **Mode:** modo da interrupÃ§Ã£o (LOW, HIGH, RISING, FALLING ou CHANGE).\n\nNo ESP32, hÃ¡ os seguintes modos de interrupÃ§Ã£o suportados para os GPIOs:\n\nâ—Â Â Â Â  **FALLING:** um modo que faz ser gerada uma interrupÃ§Ã£o quando um GPIO vai do nÃ­vel alto (3V3) para nÃ­vel baixo (0V). Ou seja, interrupÃ§Ã£o gerada na transiÃ§Ã£o de nÃ­vel alto para baixo;\n\nâ—Â Â Â Â  **RISING:** um modo que faz ser gerada uma interrupÃ§Ã£o quando um GPIO vai do nÃ­vel baixo (0V) para nÃ­vel alto (3V3). Ou seja, interrupÃ§Ã£o gerada na transiÃ§Ã£o de nÃ­vel baixo para alto;\n\nâ—Â Â Â Â  **LOW:** um modo que faz ser gerada uma interrupÃ§Ã£o gerada quando o GPIO estÃ¡ em nÃ­vel baixo;\n\nâ—Â Â Â Â  **HIGH:** um modo que faz ser gerada uma interrupÃ§Ã£o gerada quando o GPIO estÃ¡ em nÃ­vel alto;\n\nâ—Â Â Â Â  **CHANGE:** um modo que faz ser gerada uma interrupÃ§Ã£o quando hÃ¡ qualquer transiÃ§Ã£o de nÃ­vel no GPIO. Ou seja, tanto de nÃ­vel baixo para alto quanto de nÃ­vel alto para baixo.\n\n#### *CÃ³digo encoder (falta testar)\n````\nconst int pinA = 34;\n\nconst int pinB = 35;\n\nconst int debounceDelay = 50;\n\nvolatile int stateA, stateB, prevStateA, prevStateB;\n\nvolatile int counter = 0;\n\nunsigned long lastDebounceTime = 0;\n\nvoid IRAM_ATTR isrA() {\n\nÂ  stateA = digitalRead(pinA);\n\nÂ  stateB = digitalRead(pinB);\n\nÂ  if (millis() - lastDebounceTime \u003e debounceDelay) {\n\nÂ Â Â  if (prevStateA == LOW \u0026\u0026 stateA == HIGH) {\n\nÂ Â Â Â Â  if (stateB == LOW) {\n\nÂ Â Â Â Â Â Â  counter++;\n\nÂ Â Â Â Â  } else {\n\nÂ Â Â Â Â Â Â  counter--;\n\nÂ Â Â Â Â  }\n\nÂ Â Â  } else if (prevStateA == HIGH \u0026\u0026 stateA == LOW) {\n\nÂ Â Â Â Â  if (stateB == LOW) {\n\nÂ Â Â Â Â Â Â  counter--;\n\nÂ Â Â Â Â  } else {\n\nÂ Â Â Â Â Â Â  counter++;\n\nÂ Â Â Â Â  }\n\nÂ Â Â  }\n\nÂ Â Â  prevStateA = stateA;\n\nÂ Â Â  prevStateB = stateB;\n\nÂ Â Â  lastDebounceTime = millis();\n\nÂ  }\n\n}\n\nvoid IRAM_ATTR isrB() {\n\nÂ  stateA = digitalRead(pinA);\n\nÂ  stateB = digitalRead(pinB);\n\nÂ  if (millis() - lastDebounceTime \u003e debounceDelay) {\n\nÂ Â Â  if (prevStateB == LOW \u0026\u0026 stateB == HIGH) {\n\nÂ Â Â Â Â  if (stateA == LOW) {\n\nÂ Â Â Â Â Â Â  counter--;\n\nÂ Â Â Â Â  } else {\n\nÂ Â Â Â Â Â Â  counter++;\n\nÂ Â Â Â Â  }\n\nÂ Â Â  } else if (prevStateB == HIGH \u0026\u0026 stateB == LOW) {\n\nÂ Â Â Â Â  if (stateA == LOW) {\n\nÂ Â Â Â Â Â Â  counter++;\n\nÂ Â Â Â Â  } else {\n\nÂ Â Â Â Â Â Â  counter--;\n\nÂ Â Â Â Â  }\n\nÂ Â Â  }\n\nÂ Â Â  prevStateA = stateA;\n\nÂ Â Â  prevStateB = stateB;\n\nÂ Â Â  lastDebounceTime = millis();\n\nÂ  }\n\n}\n\nvoid setup() {\n\nÂ  pinMode(pinA, INPUT);\n\nÂ  pinMode(pinB, INPUT);\n\nÂ  attachInterrupt(digitalPinToInterrupt(pinA), isrA, CHANGE);\n\nÂ  attachInterrupt(digitalPinToInterrupt(pinB), isrB, CHANGE);\n\nÂ  Serial.begin(9600);\n\n}\n\nvoid loop() {\n\nÂ  Serial.println(counter);\n\nÂ  delay(100);\n\n}\n\n## 3.2. Dual core ESP32\n\nPara leitura do encoder e controle do motor simultÃ¢neo serÃ£o utilizados os 2 processadores da esp\n\n### *CÃ³digo Multitask (falta testar)\n\n#include \u003cBluetoothSerial.h\u003e\n\nBluetoothSerial SerialBT;\n\nTaskHandle_t TaskBluetooth;\n\nTaskHandle_t TaskSerial;\n\n///////////////////////////////////InicializaÃ§Ã£o tarefa 1: Encoder ////////////////////////////////////////////\n\n//Definindo pinos\n\nconst int pin_ena = 15;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //habilita o motor\n\nconst int pin_dir = 5;Â Â Â Â Â Â Â Â Â Â  Â Â Â Â Â Â Â Â Â Â Â Â Â //determina a direÃ§Ã£o\n\nconst int pin_pul = 4;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //executa um passo\n\n//Variaveis para leitura mensagem bt\n\nString comando;\n\nString letra;\n\n//VariÃ¡veis para controle do motor\n\nboolean direcao = HIGH;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // low AH - high H\n\nboolean enable = LOW;\n\nboolean pulso = LOW;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //estado inicial do pulso (borda de decida)\n\nint step = 4000;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //Conta x pulsos\n\nint periodo = 6;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  Â Â Â Â Â Â Â /* microsegundos (periodo minimo)\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  Frequencia do driver 200kHz (ou seja, 1 pulso em 1/200k=0.005 ms=5us).\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  O ideal seria 2.5 (positivo e negativo), mas vamos trabalhar com margem*/\n\n//VariÃ¡veis para calculo/conversÃ£o\n\nint tempo;\n\nint angulo;\n\nint pul_rev;\n\n//Flags intermediarias\n\nint ang_neg=0;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //flag sinal angulo\n\nint flag=0;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //flag valor pul_rev recebido\n\nint stay=0;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //flag comando permanecer ligado\n\nvoid setup() {\n\nÂ  Serial.begin(9600);\n\nÂ  pinMode(pin_ena, OUTPUT);\n\nÂ  pinMode(pin_dir, OUTPUT);\n\nÂ  pinMode(pin_pul, OUTPUT);\n\nÂ  digitalWrite(pin_ena, enable);\n\nÂ  digitalWrite(pin_dir, direcao);\n\nÂ  digitalWrite(pin_pul, pulso);\n\nÂ  SerialBT.begin(\"Controle remoto\"); // Nome do dispositivo para comunicaÃ§Ã£o BT\n\nÂ  xTaskCreatePinnedToCore(\n\nÂ Â Â  TaskBluetoothCode,\n\nÂ Â Â  \"Bluetooth\",\n\nÂ Â Â  100000,\n\nÂ Â Â  NULL,\n\nÂ Â Â  1,\n\nÂ Â Â  \u0026TaskBluetooth,\n\nÂ Â Â  0\n\nÂ  );\n\nÂ  xTaskCreatePinnedToCore(\n\nÂ Â Â  TaskSerialCode,\n\nÂ Â Â  \"Serial\",\n\nÂ Â Â  10000,\n\nÂ Â Â  NULL,\n\nÂ Â Â  1,\n\nÂ Â Â  \u0026TaskSerial,\n\nÂ Â Â  1\n\nÂ  );\n\n}\n\nvoid TaskBluetoothCode(void *pvParameters) {\n\nÂ  while (1) {\n\nÂ Â Â  while(!flag){\n\nÂ Â Â Â Â  SerialBT.println(\"Informe valor pul_rev definido nas chaves do HSS86\");\n\nÂ Â Â Â Â  delay(5000);\n\nÂ Â Â Â Â Â Â  if (SerialBT.available()) { //Verifica se hÃ¡ dados disponÃ­veis na conexÃ£o Bluetooth\n\nÂ Â Â Â Â Â Â Â Â  comando=SerialBT.readStringUntil('\\n');\n\nÂ Â Â Â Â Â Â Â Â  pul_rev=comando.toInt();\n\nÂ Â Â Â Â Â Â Â Â  switch(pul_rev){\n\nÂ Â Â Â Â Â Â Â Â Â Â  case 400:Â Â  case 800:Â Â  case 1000:Â  case 1600:\n\nÂ Â Â Â Â Â Â Â Â Â Â  case 2000:Â  case 3200:Â  case 4000:Â  case 5000:\n\nÂ Â Â Â Â Â Â Â Â Â Â  case 6400:Â  case 8000:Â  case 10000: case 12800:\n\nÂ Â Â Â Â Â Â Â Â Â Â  case 20000: case 25600: case 40000: case 51200:\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  SerialBT.print(\"Pul_rev = \");Â  SerialBT.println(pul_rev);\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  SerialBT.println(\"Envie um comando\");\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  flag=1;\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â  break;\n\nÂ Â Â Â Â Â Â Â Â Â Â  default:\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â  SerialBT.println(\"ERRO1. Obs: default=400\");\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â  break;\n\nÂ Â Â Â Â Â Â Â Â  }\n\nÂ Â Â Â Â Â Â  }\n\nÂ Â Â  }\n\nÂ Â Â  if (SerialBT.available()) {\n\nÂ Â Â Â Â  comando= SerialBT.readStringUntil('\\n');Â  // LÃª o comando enviado pelo dispositivo remoto\n\nÂ Â Â Â Â  comando.replace(\"\\n\", \"\");Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // Remove o caractere '\\n' da string\n\nÂ Â Â Â Â  letra=comando[0];\n\nÂ Â Â Â Â  comando.replace(letra, \"\");\n\nÂ Â Â Â Â  switch(letra[0]){Â \n\nÂ Â Â Â Â Â Â  //DireÃ§Ã£o\n\nÂ Â Â Â Â Â Â  case 'D':\n\nÂ Â Â Â Â Â Â  case 'd':\n\nÂ Â Â Â Â Â Â Â Â  if(comando[0]=='0'){SerialBT.println(\"mudei direÃ§Ã£o pra 0\");direcao=0;}\n\nÂ Â Â Â Â Â Â Â Â  else if(comando[0]=='1'){SerialBT.println(\"mudei direÃ§Ã£o pra 1\"); direcao=1;}Â Â Â \n\nÂ Â Â Â Â Â Â Â Â  else{SerialBT.println(\"ERRO2\");}\n\nÂ Â Â Â Â Â Â Â Â  SerialBT.print(\"dir = \"); SerialBT.println(direcao);\n\nÂ Â Â Â Â Â Â Â Â  digitalWrite(pin_dir, direcao);\n\nÂ Â Â Â Â Â Â  break;\n\nÂ Â Â Â Â Â Â  //Enable\n\nÂ Â Â Â Â Â Â  case 'E':\n\nÂ Â Â Â Â Â Â  case 'e' :\n\nÂ Â Â Â Â Â Â Â Â  if(comando[0]=='0'){enable=0;}\n\nÂ Â Â Â Â Â Â Â Â  else if(comando[0]=='1'){enable=1;}Â Â Â \n\nÂ Â Â Â Â Â Â Â Â  else{SerialBT.println(\"ERRO3\");}\n\nÂ Â Â Â Â Â Â Â Â  digitalWrite(pin_ena, enable);\n\nÂ Â Â Â Â Â Â Â Â  SerialBT.print(\"ena = \"); SerialBT.println(enable);\n\nÂ Â Â Â Â Â Â  break;\n\nÂ Â Â Â Â Â Â  //Periodo em us\n\nÂ Â Â Â Â Â Â  case 'P':\n\nÂ Â Â Â Â Â Â  case 'p':\n\nÂ Â Â Â Â Â Â Â Â  periodo=comando.toInt();Â  //forÃ§ar que o numero seja par\n\nÂ Â Â Â Â Â Â Â Â  SerialBT.print(\"periodo (us) = \"); SerialBT.println(periodo);\n\nÂ Â Â Â Â Â Â  break;\n\nÂ Â Â Â Â Â Â  //Numero de passos (Steps)\n\nÂ Â Â Â Â Â Â  case 'S':\n\nÂ Â Â Â Â Â Â  case 's':\n\nÂ Â Â Â Â Â Â Â Â  if(comando[0]=='.'){SerialBT.println(\"FicarÃ¡ ligado atÃ© comando stop\"); step=1; stay=1;}\n\nÂ Â Â Â Â Â Â Â Â  else{\n\nÂ Â Â Â Â Â Â Â Â Â Â  step=comando.toInt();\n\nÂ Â Â Â Â Â Â Â Â Â Â  SerialBT.print(\"step = \");Â Â  SerialBT.println(step);\n\nÂ Â Â Â Â Â Â Â Â  }\n\nÂ Â Â Â Â Â Â  break;\n\nÂ Â Â Â Â Â Â  //Angulo de rotaÃ§Ã£o em graus\n\nÂ Â Â Â Â Â Â  case 'A':\n\nÂ Â Â Â Â Â Â  case 'a':\n\nÂ Â Â Â Â Â Â Â Â  SerialBT.print(\"angulo = \");\n\nÂ Â Â Â Â Â Â Â Â  if(comando[0]=='-'){ang_neg=1; direcao=0; comando.replace(\"-\", \"\");SerialBT.print(\"-\");}\n\nÂ Â Â Â Â Â Â Â Â  else{ang_neg=0; direcao=1; SerialBT.print(\"+\");}Â Â Â Â Â \n\nÂ Â Â Â Â Â Â Â Â  digitalWrite(pin_dir, direcao);\n\nÂ Â Â Â Â Â Â Â Â  angulo=comando.toInt();Â \n\nÂ Â Â Â Â Â Â Â Â  step=angulo*(pul_rev)/360;\n\nÂ Â Â Â Â Â Â Â Â  SerialBT.println(angulo);\n\nÂ Â Â Â Â Â Â  break;\n\nÂ Â Â Â Â Â Â  default:\n\nÂ Â Â Â Â Â Â Â Â  SerialBT.println(\"ERRO4\");\n\nÂ Â Â Â Â Â Â  break;\n\nÂ Â Â Â Â  }\n\nÂ Â Â Â Â  if(periodo\u003c5){periodo=6;SerialBT.println(\"ERRO5\"); SerialBT.println(\"OBS: Periodo mÃ­nimo = 5us (fmax=200kHz). Periodo setado para 6us\");}\n\nÂ Â Â Â Â  else{SerialBT.println(\"frequencia dentro da permitida\u003e5us\");}\n\nÂ Â Â Â Â  SerialBT.print(\"\\nperiodo (us)= \");Â  SerialBT.println(periodo);\n\nÂ Â Â Â Â  SerialBT.print(\"step = \");Â  SerialBT.println(step);\n\nÂ Â Â Â Â  SerialBT.print(\"direcao = \");Â  SerialBT.println(direcao);\n\nÂ Â Â Â Â  SerialBT.print(\"enable = \");Â  SerialBT.println(enable);\n\nÂ Â Â Â Â  if(enable){\n\nÂ Â Â Â Â Â Â  SerialBT.println(\"Iniciado\");\n\nÂ Â Â Â Â Â Â  for(int i=0; i\u003cstep; i++){\n\nÂ Â Â Â Â Â Â Â Â  pulso = !pulso;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //inverte o estado da variÃ¡vel\n\nÂ Â Â Â Â Â Â Â Â  digitalWrite(pin_pul, pulso);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //atribui o novo estado Ã  porta\n\nÂ Â Â Â Â Â Â Â Â  delayMicroseconds(((Â Â  periodo/2Â  )*2)/2);Â Â Â Â Â Â Â Â  //tempo em alta do pulso (divide por 2 e multiplica por 2 pra ter certeza q vai ser inteiro)\n\nÂ Â Â Â Â Â Â Â Â  pulso = !pulso;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //inverte o estado da variÃ¡vel\n\nÂ Â Â Â Â Â Â Â Â  digitalWrite(pin_pul, pulso);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //atribui o novo estado Ã  porta\n\nÂ Â Â Â Â Â Â Â Â  delayMicroseconds(((Â Â  periodo/2Â  )*2)/2);Â Â Â Â Â Â Â Â  //tempo em baixa do pulso (divide por 2 e multiplica por 2 pra ter certeza q vai ser inteiro)\n\nÂ Â Â Â Â Â Â Â Â  if(stay){i--;}\n\nÂ Â Â Â Â Â Â Â Â  if (SerialBT.available()) {Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // Verifica se hÃ¡ dados disponÃ­veis na conexÃ£o Bluetooth\n\nÂ Â Â Â Â Â Â Â Â Â Â  comando= SerialBT.readStringUntil('\\n');Â Â Â Â Â Â Â Â  // LÃª o comando enviado pelo dispositivo remoto\n\nÂ Â Â Â Â Â Â Â Â Â Â  comando.replace(\"\\n\", \"\");Â Â Â Â  Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Remove o caractere '\\n' da string\n\nÂ Â Â Â Â Â Â Â Â Â Â  if(comando==\"stop\"){SerialBT.println(\"ForÃ§ada parada\"); i=step;stay=0;}\n\nÂ Â Â Â Â Â Â Â Â  }\n\nÂ Â Â Â Â Â Â  }\n\nÂ Â Â Â Â Â Â  enable=0;\n\nÂ Â Â Â Â Â Â  //se o angulo foi colocado como negativo, Ã© preciso corrigir o sentido de giro apos comando\n\nÂ Â Â Â Â Â Â  if(ang_neg){direcao=1; ang_neg=0;digitalWrite(pin_dir, direcao);SerialBT.println(\"Angulo negativo, direÃ§ao resetada\");}\n\nÂ Â Â Â Â Â Â  SerialBT.println(\"Comando recebido: \" + comando);\n\nÂ Â Â Â Â Â Â  SerialBT.println(\"\\nEnvie um comando\");\n\nÂ Â Â Â Â  }\n\nÂ Â Â  }\n\nÂ Â Â  // Adicione aqui qualquer outra lÃ³gica relacionada Ã  tarefa Bluetooth\n\nÂ Â Â  vTaskDelay(100 / portTICK_PERIOD_MS);\n\nÂ  }\n\n}\n\nvoid TaskSerialCode(void *pvParameters) {\n\nÂ  while (1) {\n\nÂ Â Â  Serial.println(\"oi mundo\");\n\nÂ Â Â  // Adicione aqui qualquer outra lÃ³gica relacionada Ã  tarefa Serial\n\nÂ Â Â  vTaskDelay(1000 / portTICK_PERIOD_MS);\n\nÂ  }\n\n}\n\nvoid loop() {}\n````\n\n# 4. Bibliografia\n\n[1]  [Dados motor de passo NEMA 34](https://www.fernandok.com/)\n[2]  [SinalizaÃ§Ã£o erro LED HSS86]([HSS86 and 2HSS86H Closed Loop Drivers (cnczone.com)](https://www.cnczone.com/forums/servo-motors-drives/356990-software.html))\n[3]  [ComunicaÃ§Ã£o CAN na ESP32 ](https://www.fernandok.com/2018/07/protocolo-can-yes-we-can.html)\n[4]  [Uso software HSS86](https://www.youtube.com/watch?v=2x_IKvZJIPQ)\n[5]  [Projeto encoder com arduino](https://easytromlabs.com/arduino/arduino-lab-09-leitura-de-um-encoder-industrial-heidenhain-com-o-arduino/)\n[6]  [Uso de interrupÃ§Ãµes na ESP32]([Uso de interrupÃ§Ãµes externas com ESP32 - MakerHero](https://www.makerhero.com/blog/uso-de-interrupcoes-externas-com-esp32/)\n[7]  [IntroduÃ§Ã£o geral sobre rede CAN](http://www.alexag.com.br/Artigos/SAE2002.pdf)\n[8]  [Tipos de CAN (low speed, high speed and FD)](https://dewesoft.com/blog/what-is-can-bus)\n\n\u003c!--\nMotor DC 4000 RPM reduÃ§Ã£o 1:8 encoder 15 passos, plataforma: Arduino\n![[esquema_direcao.jpg]]\n--\u003e","lastmodified":"2023-06-15T12:59:49.387182869Z","tags":null},"/FESiar%C3%A1":{"title":"FÃ³rmula-E SiarÃ¡ Wiki","content":"\n\u003e[!tip] EntÃ£o, vocÃª quer saber mais sobre o FÃ³rmula-E SiarÃ¡?\n\nNossa equipe Ã© formada por alunos de diferentes cursos de engenharia e Ã¡reas afins, que trabalham em conjunto para criar um carro inovador, eficiente e competitivo.\n\nNeste site, vocÃª vai conhecer um pouco mais sobre o nosso projeto e as principais caracterÃ­sticas do nosso carro. Vamos apresentar os sistemas que compÃµem o veÃ­culo e os desafios que enfrentamos para desenvolvÃª-los. Esperamos que vocÃª se inspire com a nossa histÃ³ria e se apaixone pelo FÃ³rmula-E SiarÃ¡!\n\n## Chassi\n\nO chassi Ã© a estrutura que sustenta todos os componentes do veÃ­culo. Ele deve ser leve, resistente e rÃ­gido o suficiente para garantir a seguranÃ§a dos ocupantes e o desempenho dinÃ¢mico do carro.Â O nosso chassi Ã© feito de tubos de aÃ§o (SAE 1020) soldados com o processo MIG/MAG, realizado por alunos da UFPB. Ele possui uma cÃ©lula de sobrevivÃªncia para o piloto, com cintos de seguranÃ§a de cinco pontos e uma barra antivolta. O chassi tambÃ©m incorpora pontos de fixaÃ§Ã£o para os sistemas de suspensÃ£o, freio, direÃ§Ã£o, propulsÃ£o e baterias.\n\n## SuspensÃ£o\n\nA suspensÃ£o Ã© o sistema responsÃ¡vel por conectar as rodas ao chassi e absorver as irregularidades do solo. Ela deve proporcionar estabilidade, conforto e aderÃªncia ao veÃ­culo. A nossa suspensÃ£o Ã© do tipo duplo A (double wishbone), com quatro braÃ§os triangulares por roda, que permitem ajustar a geometria da suspensÃ£o de acordo com as condiÃ§Ãµes da pista. A suspensÃ£o tambÃ©m conta com amortecedores a gÃ¡s e barras estabilizadoras, que controlam o movimento vertical e lateral do carro.\n\n## Sistema de Freio\n\nO sistema de freio Ã© o sistema responsÃ¡vel por reduzir a velocidade ou parar o veÃ­culo. Ele deve ser confiÃ¡vel, eficaz e modulÃ¡vel. O nosso sistema de freio Ã© composto por quatro discos ventilados de aÃ§o inoxidÃ¡vel, acionados por pinÃ§as de quatro pistÃµes cada. O sistema tambÃ©m possui um cilindro mestre duplo com um regulador de pressÃ£o entre os circuitos dianteiro e traseiro, que permite ajustar o equilÃ­brio de frenagem entre as rodas. AlÃ©m disso, o sistema conta com um dispositivo anti-bloqueio (ABS), que evita que as rodas travem em situaÃ§Ãµes de emergÃªncia.\n\n## Sistema de PropulsÃ£o (Powertrain)\n\nO sistema de propulsÃ£o Ã© o sistema responsÃ¡vel por gerar e transmitir a potÃªncia do motor para as rodas. Ele deve ser potente, eficiente e durÃ¡vel.Â O nosso sistema de propulsÃ£o Ã© baseado em um motor elÃ©trico sÃ­ncrono de Ã­mÃ£ permanente, que produz 80 kW (109 CV) de potÃªncia mÃ¡xima e 220 Nm (22,4 kgf.m) de torque mÃ¡ximo. O sistema tambÃ©m possui uma transmissÃ£o por corrente e uma embreagem centrÃ­fuga, que acopla ou desacopla o motor das rodas traseiras\n\n### Inversor de FrequÃªncia\n\nO [Inversor de FrequÃªncia](notes/elÃ©trica/Inversor%20de%20FrequÃªncia) Ã© o dispositivo responsÃ¡vel por controlar a velocidade do motor elÃ©trico, variando a frequÃªncia e a tensÃ£o que Ã© fornecida a ele. Ele converte a corrente alternada fixa da rede elÃ©trica em uma corrente alternada variÃ¡vel, usando uma tÃ©cnica chamada modulaÃ§Ã£o por largura de pulso (PWM). O inversor de frequÃªncia permite ajustar a velocidade do motor de acordo com a demanda da operaÃ§Ã£o, otimizando o consumo de energia e o desempenho do veÃ­culo. O nosso inversor de frequÃªncia Ã© um modelo compacto e robusto, que possui proteÃ§Ãµes contra sobrecarga, curto-circuito e sobretensÃ£o. Ele tambÃ©m possui uma interface de comunicaÃ§Ã£o com o sistema de eletrÃ´nica embarcada, que permite monitorar e controlar os parÃ¢metros do motor.\n\n### Baterias\n\nO mÃ³dulo de [baterias](notes/elÃ©trica/Baterias) Ã© responsÃ¡vel por monitorar e proteger o pacote de baterias que alimenta o motor elÃ©trico.Â O pacote Ã© composto por 120 cÃ©lulas de Ã­ons de lÃ­tio, conectadas em sÃ©rie e paralelo, que fornecem uma tensÃ£o nominal de 400 V e uma capacidade de 15 Ah \\[[4.1](https://blog.kalatec.com.br/inversor-de-frequencia/))]. O mÃ³dulo de baterias mede a tensÃ£o, a corrente e a temperatura de cada cÃ©lula, alÃ©m do estado de carga (SOC) e do estado de saÃºde (SOH) do pacote. O mÃ³dulo tambÃ©m controla os relÃ©s e os fusÃ­veis que isolam o pacote da rede elÃ©trica do veÃ­culo em caso de falha ou emergÃªncia. O mÃ³dulo ainda envia dados para o sistema de telemetria e para o inversor de frequÃªncia, que usa essas informaÃ§Ãµes para otimizar o controle do motor.\n\n\n## EletrÃ´nica\n\nA eletrÃ´nica Ã© o conjunto de circuitos e componentes que gerenciam e controlam os diversos sistemas do veÃ­culo. Ela Ã© responsÃ¡vel por coletar, processar e transmitir dados e sinais entre os sensores, atuadores, dispositivos de entrada e saÃ­da e o sistema de telemetria. A nossa eletrÃ´nica Ã© dividida em mÃ³dulos que se comunicam por meio de um barramento CAN (Controller Area Network), que garante uma alta velocidade e confiabilidade na troca de informaÃ§Ãµes. Alguns dos mÃ³dulos que compÃµem a nossa eletrÃ´nica sÃ£o:\n\n### DireÃ§Ã£o\n\nO mÃ³dulo de [direÃ§Ã£o elÃ©trica](DireÃ§Ã£o.md) Ã© responsÃ¡vel por controlar o sistema de direÃ§Ã£o elÃ©trica assistida (EPS), que auxilia o piloto na conduÃ§Ã£o do veÃ­culo. O EPS consiste em um motor elÃ©trico acoplado Ã  coluna de direÃ§Ã£o, que aplica um torque proporcional Ã  forÃ§a exercida pelo piloto no volante. O mÃ³dulo de direÃ§Ã£o recebe o sinal do sensor de torque no volante e envia um comando para o motor do EPS, ajustando o nÃ­vel de assistÃªncia conforme a velocidade do veÃ­culo. O mÃ³dulo tambÃ©m monitora a temperatura e a corrente do motor do EPS, alÃ©m de enviar dados para o sistema de telemetria.\n\n## Telemetria\n\nA telemetria Ã© o sistema responsÃ¡vel por transmitir e receber dados entre o veÃ­culo e uma estaÃ§Ã£o base. Ela permite acompanhar em tempo real o funcionamento e o desempenho do veÃ­culo durante os testes e as provas da competiÃ§Ã£o. A nossa telemetria usa um transceptor sem fio que opera na faixa de 2,4 GHz, com uma taxa de transmissÃ£o de 250 kbps. O transceptor se comunica com um computador na estaÃ§Ã£o base, que exibe os dados em uma interface grÃ¡fica desenvolvida pela equipe. A telemetria tambÃ©m permite enviar comandos para o veÃ­culo, como ligar ou desligar sistemas ou alterar parÃ¢metros de controle.\n\nConsiderando essenciais os sentores: IMU, GPS, de velocidade das rodas, LIDAR e cÃ¢meras. Freio, propulsÃ£o, suspensÃ£o â†’ serÃ£o analisados e incluÃ­dos futuramente. EntÃ£o sÃ³ vamos trabalhar com dados dos primeiros tanto para transmitir tanto quanto para dar entrada no controle. \n\nPara o sensor de RPM a melhor soluÃ§Ã£o Ã© fazer como em carros comerciais, usando o sensor ABS. Que se trata de um sensor indutivo acoplado mirando os dentes da engrenagem do eixo da roda, possibilitando haver uma boa resoluÃ§Ã£o em velocidades altas ou baixas, nÃ£o pode ser confundido com a saÃ­da do eixo do motor, em que pode haver uma reduÃ§Ã£o dele para as rodas. Este sensor mede o RPM real das rodas, nÃ£o a velocidade do motor.\n\nSobre a Inter comunicaÃ§Ã£o(interna), todos subsistemas se comunicarÃ£o com o protocolo CAN, assim como Ã© feito em modelos comerciais e carros de maior porte. SerÃ¡ um sistema hÃ­brido com vÃ¡rios controladores e sensores, independentes, mas trabalhando em conjunto com o computador principal, o qual processa vÃ­deo e envia dados para a telemetria.\n\n\n\n\u003e[!INFO] Veja tambÃ©m sobre:\n\u003e\n\u003e ğŸ”—[Escolha de sensores](notes/elÃ©trica/Escolha%20de%20sensores.md) \u003cbr/\u003e\n\u003e ğŸ”— [Simulador](notes/telemetria/Simulador.md) \u003cbr/\u003e\n\u003e ğŸ”—  [Controle manual Ã  distÃ¢ncia](notes/elÃ©trica/Controle%20manual%20Ã %20distÃ¢ncia) \u003cbr/\u003e\n","lastmodified":"2023-06-15T12:59:49.387182869Z","tags":null},"/notes/el%C3%A9trica/Balanceamento-de-Baterias":{"title":"Balanceamento de Baterias","content":"","lastmodified":"2023-06-15T12:59:49.435182576Z","tags":null},"/notes/el%C3%A9trica/Baterias":{"title":"Baterias","content":"\n# Objetivos e Desafios\n\nA Bateria precisa ter uma capacidade de carga razoÃ¡vel\nA Bateria precisa ser carregada com desgaste mÃ­nimo\nPrecisamos de [[notes/elÃ©trica/Battery Managment System|monitoriamento]] constante (pra reduzir o desgaste e manter seguranÃ§a quÃ­mica da bateria)\n# Como Estamos?\nAtualmente usamos 4 baterias de chumbo-Ã¡cido de 12V em sÃ©rie, com capacidade individual de 115Ah\n# Futuro\nSubstituiÃ§Ã£o por baterias de [Ãon de LÃ­tio](notes/elÃ©trica/Estudo%20de%20Baterias%20Substitutivas.md)\n","lastmodified":"2023-06-15T12:59:49.435182576Z","tags":null},"/notes/el%C3%A9trica/Battery-Managment-System":{"title":"Battery Managment System","content":"\nUm sistema de gerenciamento de bateria (**battery management system**) Ã© qualquer sistema eletrÃ´nico que gerencie uma bateria recarregÃ¡vel (seja uma Ãºnica cÃ©lula ou um conjunto), protegendo-a de surtos de corrente, monitorando seu estado, calculando dados secundÃ¡rios, enviar esses dados, controlar o ambiente na qual ela se encontra e/ou [[notes/elÃ©trica/Balanceamento de Baterias|balanceando-a]].\n\nAÂ [battery pack](https://en.wikipedia.org/wiki/Battery_pack \"Battery pack\")Â built together with a battery management system with an external communicationÂ [data bus](https://en.wikipedia.org/wiki/Bus_(computing) \"Bus (computing)\")Â is aÂ [smart battery pack](https://en.wikipedia.org/wiki/Smart_battery_pack \"Smart battery pack\"). A smart battery pack must be charged by aÂ [smart battery charger](https://en.wikipedia.org/wiki/Smart_battery_charger \"Smart battery charger\").","lastmodified":"2023-06-15T12:59:49.435182576Z","tags":null},"/notes/el%C3%A9trica/CANopen":{"title":"CANopen","content":"\n# IntroduÃ§Ã£o\nCANopen Ã© um protocolo de comunicaÃ§Ã£o de rede amplamente utilizado na indÃºstria, especialmente na automaÃ§Ã£o industrial. Ele foi desenvolvido como uma forma padronizada de comunicaÃ§Ã£o entre dispositivos eletrÃ´nicos em uma rede [CAN (Controller Area Network)](https://en.wikipedia.org/wiki/CAN_bus).\n\n# Funcionamento\nO funcionamento do CANopen Ã© baseado fundamentalmente no protocolo CAN, mas inclui uma camada de abstraÃ§Ã£o adicional que permite uma comunicaÃ§Ã£o mais flexÃ­vel e robusta entre os dispositivos industriais. Ele inclui um conjunto de mensagens padronizadas que podem ser usadas para enviar e receber dados, alÃ©m de mecanismos de gerenciamento de rede e diagnÃ³stico.\n\nA implementaÃ§Ã£o do CANopen envolve a conexÃ£o de dispositivos eletrÃ´nicos compatÃ­veis atravÃ©s de uma rede CAN fÃ­sica, usando cabos e conectores padronizados. Cada dispositivo na rede Ã© atribuÃ­do a um endereÃ§o Ãºnico e pode ser configurado para enviar ou receber mensagens especÃ­ficas. Um gerenciador de rede entÃ£o pode ser usado para configurar e monitorar os dispositivos (como sensores e o prÃ³prio inversor de frequÃªncia) na rede, bem como para diagnosticar eventuais problemas.","lastmodified":"2023-06-15T12:59:49.435182576Z","tags":null},"/notes/el%C3%A9trica/Controle-manual-%C3%A0-dist%C3%A2ncia":{"title":"Controle manual Ã  distÃ¢ncia","content":"\nPara controle do carro no simulador ou mesmo fisicamente, existe a opÃ§Ã£o de usar um controle especializado, como os drones possuem, entretanto, havendo boa infraestrutura de telemetria podemos usar alguns controles mais simples como teclado ou mesmo um gamepad, havendo confiabilidade e mecanismos de seguranÃ§a. Nesse sentido temos o mÃ³dulo `ds4input` que recebe entrada de um controle de PS4 e transmite via tÃ³picos do ROS para controle do carro. \n\nNo momento faÃ§a: `ros2 run ds4input main`\n\nO cÃ³digo escreverÃ¡ a mensagem AckermannSteeringStamped no tÃ³pico `/cmd`\nApÃ³s abrir o simulador apenas colocar em modo manual, e a entrada via controle funciona, nÃ£o mexer com comandos de velocidade do launcher usando o controle, atÃ© o momento a integraÃ§Ã£o nÃ£o Ã© completa.","lastmodified":"2023-06-15T12:59:49.435182576Z","tags":null},"/notes/el%C3%A9trica/Escolha-de-sensores":{"title":"Escolha de sensores","content":"\nOK\n- IMU MPU 9250, um nÃ­vel acima do mais bÃ¡sico, MPU6050\n- GPS Ublox neo 6m / m8n\n- RPM: simples encoder Ã³ptico(incremental), pode atÃ© ser DIY impresso 3D, no caso mais simples de acoplar sendo sÃ³ um disco que vai ser lido pelo encoder de quadratura. SenÃ£o temos duas opÃ§Ãµes, usar um encoder Ã³ptico rotativo direto na roda/eixo ou com uma reduÃ§Ã£o com uma constante alterada em software.\n- TransmissÃ£o de dados: par de ESP32 com anteninha ou um microcontrolador com wifi mais forte.\n\nBOM\n- IMU: Bosch BNO055. Justificativa â†’ Ã‰ um pouco melhor que o 9250, mas aparentemente incrÃ­vel. O BNO tem um algoritmo de fusÃ£o sensorial que pode ajudar com a parte do GPS, removendo peso do controlador principal. Ganha em alguns aspectos do 9250\n- GPS: SparkFun GPS-RTK2 Board - ZED-F9P â†’ 0,05 m/s, dobro do ultimo, ODR de 8 a 25 Hz, dependendo do modo. Aparentemente 1,5m de erro, nÃ£o fica muito claro na datasheet. Tem dois tipos de medidas o PVT, aparentemente o padrÃ£o de todos, de onde eu tirei os 1,5m. TambÃ©m tem o RTK, que pode ser preciso por atÃ© 10cm, supostamente segundo a datasheet, mas esse mÃ©todo Ã© mais preciso mesmo. Precisa importar.\n- Sensor indutivo industrial, simples, a ser acoplado na engrenagem do eixo da roda, o que varia vai ser a frequÃªncia e distÃ¢ncia de ativaÃ§Ã£o.\n- TransmissÃ£o de dados: ZigBee/LoRa\n\nExcelente\n- IMU, GPS, barÃ´metro: VectorNav VN-300, Ã© um INU, intertial navigation system. Possui todas as funÃ§Ãµes, Ã© sÃ³ um dos modelos usados para mÃ¡quinas pesadas de campo, ou mesmo navios, Ã© um grande exagero, contudo, Ã© mais que excelente.\n- RPM: sensor indutivo comercial especificamente para carros.\n- TransmissÃ£o de dados: HolyBro SiK Telemetry Radio V3, similar ao do PixHawk4\n\nTransmissÃ£o de dados\nAlgumas situaÃ§Ãµes sÃ£o possÃ­veis, considerando que serÃ£o transmitidos os dados dos sensores apenas, sem cÃ¢meras ou LIDAR, devido ao grande volume de dados, importando mais o controle e condiÃ§Ãµes de operaÃ§Ã£o do carro\n- para um setup mais simples, um ESP32 ou mesmo o Wi-Fi do Raspberry Pi podem ser suficientes, unidos de um bom roteador, sendo possÃ­vel andar um pouco apenas para tester simples. \n- Outra opÃ§Ã£o Ã© usar um mÃ³dulo 4G no Raspberry Pi, no entanto acrescenta complexidade. \n- HÃ¡ mÃ³dulos de rÃ¡dio LoRa que alcanÃ§am quilometros de distÃ¢ncia e possuem protocolo robusto, o LoRaWAN, basicamente o mÃ³dulo Ã© uma camada, para os bytes brutos, a comunicaÃ§Ã£o real seria com MQTT ou TCP/IP.\n- O ideal Ã© um mÃ³dulo de rÃ¡dio como que os drones possuem, no entanto o preÃ§o Ã© alto.\n","lastmodified":"2023-06-15T12:59:49.435182576Z","tags":null},"/notes/el%C3%A9trica/Estudo-de-Baterias-Substitutivas":{"title":"Estudo de Baterias Substitutivas","content":"\nRessalvas iniciais:\n\nAs baterias consideradas inicialmente foram baterias lÃ­tio cilÃ­ndrica, em especial pelo seu valor e pela menor necessidade de cuidados especiais que sÃ£o necessÃ¡rios nas cÃ©lulas prismÃ¡ticas (Maior cuidado com a temperatura e pressÃ£o do ambiente).\n\nPressupondo um nÃ­vel mÃ©dio de tensÃ£o por cÃ©lula de 3.6V. Com tensÃ£o total necessÃ¡ria de 72V e Energia Total aproximada de [6.5kWh](https://webthesis.biblio.polito.it/15660/), obtemos as seguintes configuraÃ§Ãµes:\n \n\n---:|Sony VTC6 :| LG HG2 :| Samsung 30Q :| Samsung 30T :| Samsung 40T :| Melasta LPA542126\n---|-------------|-----|-----------|-------------|-------------|--------------------\nDimensions|18650 |18650 | 18650 | 21700 | 21700 | Primastic\nNominal capacity [mAh] | 3120 | 3000 | 3040 | 3000 | 4000 | 6000\nNominal voltage [V] | 3,6 | 3,6 | 3,6 | 3,6 | 3,6 | 3,7\nEnergy density [Wh/g] | 0,240 | 0,230 | 0,240 | 0,158 | 0,216 | 0,175\nInternal impedance [â„¦] | 0,13 | 0,20 | 0,13 | 0,13 | 0,12 | \nMaximum continuous discharge current [A] | 20 | 20 | 15 | 35 | 35 | 56\nEnergy/pack of 20 [Wh] | 224.64 | 216 | 218.88 | 216 | 288 | 444\nNumber of Packs to supply 6.5kWh | 28.9 | 30.1 | 29.7 | 30.1 | 22.6 | 14.6\nTotal number of Cells | 600 | 640 | 600 | 640 | 480 | 320\nTotal weight (Only Cells) [kg] | 25.0 | 26.1 | 25.0 | 38.0 | 27.8 | 34.3\n\nTendo uma tensÃ£o total de 72V, devemos \"serializar\" 20 cÃ©lulas. (72V\\\\3.6V)\nAlÃ©m disso, temos dois limitantes para o nÃºmero de packs: a Energia Total e a Corrente de descarga. Nosso contingente de Energia atual totaliza 5.5kWh.\n\nPara calcular a Corrente que serÃ¡ puxada da nossa bateria, basta especificarmos a potÃªncia da nossa carga. Pelas especificaÃ§Ãµes, obtemos: 7.5kW do motor, 0.6kW em perdas do Inversor e 0.4kW de componentes eletrÃ´nicos, obtemos um total de 8.5kW.\u003cbr/\u003e\nPortanto, podemos esperar uma corrente de 120A (8.5kW\\\\72V). Criando um limitante mÃ­nimo para cada possÃ­vel cÃ©lula:\n\n---|Sony VTC6 | LG HG2 | Samsung 30Q | Samsung 30T | Samsung 40T | Melasta LPA542126\n---|-------------|-----|-----------|-------------|-------------|--------------------\nMaximum continuous discharge current [A] | 20 | 20 | 15 | 35 | 35 | 56\nMinimum number of parallel 20 cells' packs to support the expected system's current| 6.0 | 6.0 | 8.0 | 3.4 | 3.4 | 2.1\n","lastmodified":"2023-06-15T12:59:49.435182576Z","tags":null},"/notes/el%C3%A9trica/Inversor-de-Frequ%C3%AAncia":{"title":"Inversor de FrequÃªncia","content":"\n# IntroduÃ§Ã£o\nUm inversor de frequÃªncia Ã© um dispositivo eletrÃ´nico que Ã© usado para controlar a velocidade de um motor elÃ©trico. Ele faz isso alterando a frequÃªncia da corrente elÃ©trica que alimenta o motor. Quando a frequÃªncia da corrente Ã© aumentada, a velocidade do motor tambÃ©m aumenta, e quando a frequÃªncia Ã© diminuÃ­da, a velocidade do motor diminui.\n\n# Funcionamento\n\nO funcionamento de um inversor de frequÃªncia Ã© relativamente simples. Ele consiste basicamente em um conversor de CC para CA. O inversor de frequÃªncia recebe uma fonte de corrente contÃ­nua de entrada e a converte em corrente alternada de saÃ­da com uma frequÃªncia (e corrente) ajustÃ¡vel. A corrente alternada de saÃ­da Ã© entÃ£o usada para alimentar o motor elÃ©trico, alterando sua velocidade de acordo com a frequÃªncia da corrente.\n\n# Nosso Carro\n\nNo nosso carro utilizamos o CVW300, um inversor de frequÃªncia da WEG projetado para ser usado em veÃ­culos elÃ©tricos. Ele Ã© capaz de controlar motores elÃ©tricos trifÃ¡sicos de baixa tensÃ£o e Ã© compatÃ­vel com tensÃµes de bateria de 24 a 72 VDC. Ele possui um controle vetorial embutido e fÃ¡cil configuraÃ§Ã£o e ajuste atravÃ©s de uma interface humano-mÃ¡quina externa (similar Ã  um controle remoto). Nossas aplicaÃ§Ãµes driverless (sem motoristas) sÃ£o suportadas nativamente por comunicaÃ§Ãµes digitais RS485 e [[CANopen]].","lastmodified":"2023-06-15T12:59:49.435182576Z","tags":null},"/notes/telemetria/simulador":{"title":"Simulador EUFS","content":"\nDecidimos por usar um simulador quase de acordo com as necessidades do projeto. Usamos uma versÃ£o modificada do simulador da equipe de Formula da Universidade de Edimburgo. Em caso de dÃºvidas, sinta-se convidado(a) a enviar criar uma issue no github.\n\n## Como instalar o simulador\nInfelizmente somente funciona em linux, algumas dependÃªncias do simulador sÃ£o do linux apesar da possibilidade de usar o ROS no Windows. No entanto, Ã© possÃ­vel usar o WSL ou o VirtualBox.\n\nOBS.: o site do EUFS lista Ubuntu 22 e ROS Galactic, mas aqui usamos outras versÃµes. \n\n### Requerimentos\n- Ubuntu 22.04\n- git\n- lsb_release\n- ROS 2 Humble\n\n### Primeiros passos\nPrimeiramente, execute\n```\nsudo add-apt-repository main\nsudo add-apt-repository universe\nsudo apt install lsb-core lsb-release -y\n```\nServe para que o script do ROS detecte a versÃ£o correta do Ubuntu, isso realmente deu uma vez erro e consumiu muito tempo. \n\nEm seguida vÃ¡ na pÃ¡gina do \u003ca href=\"https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debians.html\"\u003eROS Humble\u003c/a\u003e, seguindo os passos tudo deve funcionar normalmente. Quando for fazer o `sudo apt install ros-humble-desktop`, nÃ£o faÃ§a, faÃ§a isso: `sudo apt install ros-humble-desktop`, para instalar todos os pacotes. Ainda vai faltar, entÃ£o faÃ§a isso:\n```\nsudo apt install ros-humble-desktop-full\n```\ne depois instale esses pacotes:\n```\nsudo apt install ros-humble-gazebo-ros ros-humble-ackermann-msgs\n```\n\nAgora para outras dependÃªncias do simulador, faÃ§a\n```\npip3 install colcon-common-extensions -U\n# se vocÃª nÃ£o tiver python:\nsudo apt install python3 python3-pip\n```\n\nFaÃ§a:\n(Obs.: nÃ£o coloque o simulador numa pasta cujo nome tenha acentos ou espaÃ§os como, ex.: ZÃ© Maria, isso impede que o seu terminal encontre a pasta de onde instalar os pacotes)\n```\ncd ~/\n\n# efetivamente fazemos o download dele\ngit clone https://github.com/Formula-E-Siara/simulador\n\n# entre no diretÃ³rio\ncd simulador\n\n\necho 'export EUFS_MASTER=$(pwd)' \u003e\u003e ~/.bashrc\n\nsource ~/.bashrc\n```\n\nVamos iniciar o workspace do ros, se vocÃª nÃ£o tiver feito\n```\nsource /opt/ros/humble/setup.bash\n```\n\nEsses comandos iniciam o gerenciador de pacote e instalam os pacotes do simulador que baixamos no `git clone`\n```\nsudo apt-get install python3-rosdep\nsudo rosdep init\nrosdep update\nrosdep install --from-paths $EUFS_MASTER --ignore-src -r -y\n```\n\nVolte para a pasta do simulador e faÃ§a:\n```\n# entrar na pasta\ncd $EUFS_MASTER\n\n# dentro da pasta\ncolcon build\n```\n\nNa hora de instalar o simulador siga o tutorial do EUFS normalmente, no entanto, ao ao chegar na parte de rosdep install, faÃ§a source do script do ROS, exemplo, baixei e compilei, abro a pasta que salvei e faÃ§o:\n```\n# se vocÃª usar zsh use .zsh ao invÃ©s de .bash\nsource ./install/setup.bash\n```\nSe faltarem mÃ³dulos na hora, pegue o nome deles e substitua underline por \"-\", e faÃ§a conforme o exemplo: \n```\n# exemplo ackermann_msgs\nsudo apt install ros-humble-ackermann-msgs\n```\nDepois colcon build e pronto. Daqui sempre que for usar o simulador faÃ§a, entre na pasta do simulador e faÃ§a\n```\n# caso nÃ£o estiver na pasta, faÃ§a:\ncd ~/eufs_modified \u0026\u0026 . install/setup.bash\n# caso estiver na pasta faÃ§a\n. install/setup.bash\n# se nÃ£o der certo substitua o . por source\n\n# para iniciar o simulador\nros2 launch eufs_launcher eufs_launcher.launch.py\n```\n","lastmodified":"2023-06-15T12:59:49.435182576Z","tags":null}}