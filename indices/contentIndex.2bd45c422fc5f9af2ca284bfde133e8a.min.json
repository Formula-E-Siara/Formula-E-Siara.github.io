{"/":{"title":"Página inicial","content":"\nTentativa de criar uma [Knowledge Base](https://pt.wikipedia.org/wiki/Base_de_conhecimento) para o projeto Fórmula-E Siará da Universidade Federal do Ceará.\n\nObjetivos:\n\n1. Criar um único local com uma verdade absoluta. Onde todos os membros podem consultar e, claro, corrigir.\n2. Promover um ponta-pé inicial para os membros recém-ingressantes.\n\n## Participe agora mesmo!\n\u003e 🌎 [Página Inicial Fórmula-E Siará](FESiará.md) \u003cbr/\u003e\n\u003e 📚 [\"Como realizar modificações na Wiki?\"](Como%20Realizar%20Modificações.md) \u003cbr/\u003e\n","lastmodified":"2023-06-15T12:59:49.387182869Z","tags":null},"/Como-Realizar-Modifica%C3%A7%C3%B5es":{"title":"Modificar a Wiki","content":"\n\u003e[!INFO] Não é simples\n\u003e\nMas também não é difícil.\n\n# Setup do GitHub\nO GitHub do Fórmula-E Siará possui total acesso aos arquivos que compõem o site. Portanto, o primeiro passo deve ser fazer o login no mesmo.\n\n## [GitHub Desktop](https://desktop.github.com/)\nAlém do acesso ao GitHub pelo navegador, torna-se necessário a instalação do GitHub Desktop para a atualização dos arquivos da Wiki.\n\nApós [baixar o GitHub Desktop](https://desktop.github.com/), é necessário realizar a clonagem do repositório:\n\n![](content/images/tutorial_github-desktop-tut1.png)\n\n![](content/images/tutorial_github-desktop-tut2.png)\n\n![](content/images/tutorial_github-desktop-tut3.png)\n\n# [Obsidian](http://obsidian.md)\n\nObsidian é a melhor forma de realizar alterações na Wiki, por já podermos ter uma prévia de como a página se tornará. Entretanto, se você estiver se sentindo **valente** pode até mesmo realizar as modificações nos arquivos ```.md``` pelo navegador ou Notepad.\n\nApós [baixar e instalar o Obsidian](https://obsidian.md/download), basta abrir um _vault_ na mesma pasta donde o repositório foi clonado, com essa opção:\n\n![](content/images/tutorial_obsidian.png)\n\nCom isso, a estrutura da wiki estará de livre alteração. Tome cuidado e não faça besteiras! 😀\n\n\n\u003e[!done] Parabéns!\n\u003e\nVocê está preparado para fazer alterações relevantes à equipe do Fórmula-e Siará! \n\n","lastmodified":"2023-06-15T12:59:49.383182893Z","tags":null},"/Dire%C3%A7%C3%A3o":{"title":"Direção","content":"\n\u003e[!tip] Não repare a bagunça, esse tópico ainda ta sendo organizado . . ...🐌\n\n\n![](content/images/tutorial_github-desktop-tut1.png)\n\n# 1. Acionamento motor por BT (HSS86)\n\n## 1.1. Motor de passo\n\n![](content/images/direcao_motor_driver.png)\n\nO motor utilizado para o projeto da direção elétrica será o Tecmaf 34080 ([TMA.ES 34080](https://tecmaf.com.br/wp-content/uploads/2020/07/TMA.ES_.34080.pdf)), motor de passo bipolar com força de 8 Nm, tal que cada passo equivale a um ângulo de 1,8°± 5%. Algumas informações sobre o motor:\n\n![](content/images/direcao_motor.png)\n\nO acionamento do motor está sendo feito com o apoio do driver dedicado ([HSS86](https://www.jbcnc.se/images/datasheets/HSS86.pdf)). O driver permite muitas funcionalidades úteis, entre elas:\n\n-       Controle em malha fechada do motor que não permite a perda de passo;\n-       Melhoria na performance em alta velocidade e alto torque;\n-       Ajuste automático de corrente baseado na carga de trabalho reduzindo o aquecimento;\n-       Frequência de resposta de pulso de 200 kHz;\n-       Possibilidade de escolha entre 16 micropassos (em escala de 400 a 51200 crosteps/rev) através das chaves físicas na lateral do driver.\n-       Proteção contra sobrecorrente, sobretensão e diferença de posição.\n\n### 1.1.1. Diagrama de conexão\n\n![](content/images/direcao_esquema_hss86.png)\n\n### 1.1.2. Fios encoder motor\n\n![](content/images/direcao_db15_cores.png)\n\n### 1.1.3. Conexão encoder com driver HSS86\n\n![](content/images/direcao_conexao_encoder_hss86.png)\n\n \n## 1.2. Hybrid Servo Driver (TMA DES HSS86)\n\n### 1.2.1. Luz segurança\n\n![](content/images/direcao_luz_seg_hss86.png)\n\n### 1.2.2. Configuração dos switches\n\nUsaremos configuração default. Para acionamento do motor não precisa tanta precisão\n\n![](content/images/direcao_microstep.png)\n\nou seja, todas as chaves devem ficar em on\n\n### 1.2.3. Controlador\n\n\u003e[!attention] Observação importante: Ligar o motor e driver com cabo desconectado poderá danificar o driver e o encoder\n\nEstaremos usando o arduino que tem tensão de sinal de 5V logo não precisa dos resistores conforme tabela abaixo. Para teste com esp (próximo tópico), usaremos um optacoplador ligado aos pinos de saída, assim escolhemos a resistência de 2,2k pois usaremos 24V para dar maior margem para caso haja queda de tensão (checar diagrama 1.1.1.)\n\n![](content/images/direcao_pinos_controle_hss86.png)\n\n#### Pinos (HSS86)\n-       ENA (Enable): HIGH habilita o motor (considerando acionamento em HIGH conforme diagrama do datasheet do HSS86)\n-       DIR (Direction): HIGH horário/ LOW anti horário.\n-       PUL (Pulse): Esta é a entrada de pulso do HSS86. Quando um pulso de sinal lógico alto é aplicado a essa entrada, o motor avança um passo ou uma posição. O número de pulsos necessários para um movimento completo depende das características do motor.\n\n#### Código (ESP32)\n\n````\nconst int pin_ena = 2; //habilita o motor\n\nconst int pin_dir = 3; //determina a direção\n\nconst int pin_pul = 4; //executa um passo\n\nint periodo = 1000; // micro segundos\n\nint step = 5; //Conta 400 pulsos\n\nboolean pulso = LOW; //estado do pulso\n\n/*Para saber a velocidade e o quanto o motor vai girar defina qual a configuração\n\ndo \"divisor\" driver, 400 pulso/rev, 800pulso/rev 1600pulso/rev e etc\n\nA velocidade será freq/divisor, onde freq= 1/periodo\n\nEX: divisor default=400; periodo= 500us; freq=1/periodo= 1kHz\n\nResulta em 1000(pulso/s)/400(pulso/rev)=2.5 rev/s e 2.5 rev/s = 150 rpm\n\n- Se por exemplo step=400, sera executado 400 passos com o divisor fica\n\nstep/divisor=400(pulsos)/400(pulso/rev) que resulta em 1 rev.\n\n- Se sao 400 pulsos com velocidade 2.5 rev/s o tempo de 1 volta será de 1rev/2.5 0.4 segundos\n\n*/\n\nvoid setup(){\n\n  pinMode(pin_ena, OUTPUT);\n\n  pinMode(pin_dir, OUTPUT);\n\n  pinMode(pin_pul, OUTPUT);\n\n  digitalWrite(pin_ena, HIGH); //habilita em high, ligando portas positivas em high\n\n  digitalWrite(pin_dir, HIGH); // low ANTIHORARIO / high HORARIO\n\n  digitalWrite(pin_pul, LOW); //borda de decida\n\n}\n\nvoid loop(){\n\n  delay(1000);\n\n  for(int i=0; i\u003cstep; i++){\n\n    pulso = !pulso; //inverte o estado da variável\n\n    digitalWrite(pin_pul, pulso); //atribui o novo estado à porta\n\n    delayMicroseconds(periodo*1000/2); //tempo em alta do pulso\n\n    pulso = !pulso; //inverte o estado da variável\n\n    digitalWrite(pin_pul, pulso); //atribui o novo estado à porta\n\n    delayMicroseconds(periodo*1000/2); //tempo em baixa do pulso\n\n  }\n\n}\n\n````\n\n#### Error\n\n![](content/images/direcao_error.png)\n## 1.3. Controlando por celular\n\nCelular(bluetooth) → ESP → optoacoplador → driver HSS86\n\n### 1.3.1. ESP (portas BT)\n\n![](content/images/direcao_pinout_esp32.png)\n### 1.3.2. (Saída ESP)\n\nNecessário entre esp e driver pq saída esp é de 3,3V\n\n#### Optacoplador TLP281-4\n\nPrático 4 entradas -\u003e 4 saídas\n![](content/images/direcao_TLP281_4.png)\n\n![](content/images/direcao_TLP281-4_esquema.png)\n\n#### Conversor de Nível Lógico 3.3V-5V Bidirecional - 2 Canais\n\nSugestão do professor, mas não achamos no lab\n\n![](content/images/direcao_conversor_nivel_logico.png)\n\n#### Optacoplador HCPL-3120\n\ntinhamos sobrando no lab\n\n![](content/images/direcao_HCPL_3120.png)\n\n\u003e[!attention] É necessário uso de um capacitor de bypass de 0,1 μF entre os pinos 5 e 8\n\nPor datasheet do opta, temos:\n\n![](content/images/direcao_HCPL_3120_datasheet.png)\n\n##### Input\n\nA tensão de entrada será da ESP32 que é de 3,3V, então o resistor de entrada deve ser 330Ω (Ωmin=3,3V/16mA=206Ω)\n\n##### Output\n\n\u003e[!attention] É necessário se atentar à necessidade de resistência entre o controlador e o driver de acordo com a tensão de controle utilizada.\nPelo datasheet, temos:\n![](content/images/direcao_resistencia_hss86.png)\n\nUsaremos alimentação de saída em 24V (tem q estar entre 15 e 30V e o datasheet do hss dá opção de 5V, 12V e 24V). Assim, lembrando pelo diagrama 1.1.1. e tabela 1.2.3. precisamos usar resistência de aproximamente 2k, usaremos 2k2 Ω\n\n### 1.3.4. (Alimentação ESP)\n\nA alimentação da esp pode ser feita pelo próprio conector USB (5,0V) ou então através do pino 5V ou VIN , com uma alimentação regulada de 5,0V\n\n#### Regulador KA7805\n\n![](content/images/direcao_KA7805.png)\n\n![](content/images/direcao_KA7805_data1.png)\n\n![](content/images/direcao_KA7805_data2.png)\n\n### 1.3.5. Aplicativo para controlar pelo celular\n\n#### Aplicativo 1: Só terminal Serial\n\n![](content/images/direcao_app1.jpg)\n\n![](content/images/direcao_app1_example.jpg)\n\n##### Código acionamento (v1)\n\n````\n#include \"BluetoothSerial.h\"\n\nconst int ena = 33; //habilita o motor\n\nconst int dir = 32; //determina a direção\n\nconst int pul = 3; //executa um passo\n\nString comando;\n\nint periodo = 500; // em ms, faixa sugerida de 100 a 2000 (obs colocar numero par)\n\nint step = 4000; //Conta x pulsos\n\nboolean pulso = LOW; //estado inicial do pulso\n\nint pul_rev;\n\nint tempo;\n\nint angulo;\n\nint flag=0;\n\nString letra;\n\nBluetoothSerial SerialBT;\n\nvoid setup() {\n\n  Serial.begin(9600); // Inicializa a porta serial para depuração\n\n  pinMode(ena, OUTPUT);\n\n  pinMode(dir, OUTPUT);\n\n  pinMode(pul, OUTPUT);\n\n  digitalWrite(ena, HIGH); //habilita em high, ligando portas positivas em high\n\n  digitalWrite(pul, LOW); //borda de decida\n\n  SerialBT.begin(\"Controle remoto\"); // Inicializa a comunicação Bluetooth\n\n}\n\nvoid loop() {\n\n  delay(500);\n\n  while(!flag){\n\n    SerialBT.println(\"Informe valor pul_rev definido nas chaves do HSS86\");\n\n    delay(5000);\n\n    if (SerialBT.available()) { // Verifica se há dados disponíveis na conexão Bluetooth\n\n      comando=SerialBT.readStringUntil('\\n');\n\n      pul_rev=comando.toInt();\n\n      SerialBT.println(\"Envie um comando\");   \n\n      flag=1;\n\n    }\n\n  }\n\n  if (SerialBT.available()) { // Verifica se há dados disponíveis na conexão Bluetooth\n\n    comando= SerialBT.readStringUntil('\\n');  // Lê o comando enviado pelo dispositivo remoto\n\n    comando.replace(\"\\n\", \"\"); // Remove o caractere '\\n' da string\n\n    letra=comando[0];\n\n    comando.replace(letra, \"\");\n\n    switch(letra[0]){     \n\n      //Direção\n\n      case 'D':\n\n      case 'd':\n\n        if(comando[0]=='0'){digitalWrite(dir, LOW); SerialBT.println(\"mudou dir pra 0\");}\n\n        else if(comando[1]=='1'){digitalWrite(dir, HIGH); SerialBT.println(\"mudou dir pra 1\");   }   \n\n        else{SerialBT.println(\"Comando inválido3\");}     \n\n        break;\n\n      //Enable\n\n      case 'E':   \n\n      case 'e' :\n\n        if(comando[0]=='0'){digitalWrite(ena, LOW);SerialBT.println(\"mudou ena pra 0\");}\n\n        else if(comando[1]=='1'){digitalWrite(ena, HIGH);SerialBT.println(\"mudou ena pra 1\");}   \n\n        else{SerialBT.println(\"Comando inválido1\");}     \n\n        break;\n\n      //Periodo em ms, faixa sugerida de 100 a 2000 (obs colocar numero par)\n\n      case 'P':\n\n      case 'p':\n\n        periodo=comando.toInt();\n\n        SerialBT.println(\"periodo alterado\");\n\n        SerialBT.println(periodo);\n\n        break;\n\n      //Numero de passos (Steps)\n\n      case 'S':\n\n      case 's':   \n\n        step=comando.toInt();\n\n        SerialBT.println(\"step alterado\");SerialBT.println(step);\n\n        break;\n\n      //Angulo de rotação em graus\n\n      case 'A':\n\n      case 'a':         \n\n        angulo=comando.toInt(); \n\n        step=angulo*(pul_rev)/180;\n\n        SerialBT.println(\"angulo alterado\");SerialBT.println(angulo);\n\n        break;\n\n      //Tempo de acionamento em ms\n\n      case 'T':\n\n      case 't': \n\n        tempo=comando.toInt();\n\n        SerialBT.println(\"tempo alterado\");SerialBT.println(tempo);\n\n        step=tempo*1000/periodo;\n\n        break;\n\n      default:\n\n        SerialBT.println(\"Comando inválido2\");\n\n        break; \n\n      }\n\n    }\n\n  for(int i=0; i\u003c=step; i++){\n\n    digitalWrite(pul, pulso); //atribui o novo estado à porta\n\n    delayMicroseconds(periodo/2); //tempo em alta do pulso\n\n    pulso = !pulso; //inverte o estado da variável\n\n    digitalWrite(pul, pulso); //atribui o novo estado à porta\n\n    delayMicroseconds(periodo/2); //tempo em baixa do pulso\n\n  }\n\n}\n\n````\n\n##### Código acionamento (v2)\n\n````\n#include \"BluetoothSerial.h\"\n\nBluetoothSerial SerialBT;\n\n//Definindo pinos\n\nconst int pin_ena = 15;                        //habilita o motor\n\nconst int pin_dir = 5;                        //determina a direção\n\nconst int pin_pul = 4;                        //executa um passo\n\n//Variaveis para leitura mensagem bt\n\nString comando;\n\nString letra;\n\n//Variáveis para controle do motor\n\nboolean direcao = HIGH;                       // low AH - high H\n\nboolean enable = LOW;\n\nvolatile boolean pulso = LOW;                          //estado inicial do pulso (borda de decida)\n\nvolatile int step = 4000;                              //Conta x pulsos\n\nvolatile unsigned long periodo = 6;                              /* microsegundos (periodo minimo)\n\n                                              Frequencia do driver 200kHz (ou seja, 1 pulso em 1/200k=0.005 ms=5us).\n\n                                              O ideal seria 2.5 (positivo e negativo), mas vamos trabalhar com margem*/\n\n//Variáveis para calculo/conversão\n\nvolatile int tempo;\n\nint angulo;\n\nint pul_rev;\n\n//Flags intermediarias\n\nint ang_neg=0;                                 //flag sinal angulo\n\nint flag=0;                                    //flag valor pul_rev recebido\n\nint stay=0;                                    //flag comando permanecer ligado\n\nvoid setup(){\n\n  Serial.begin(9600);                          // Inicializa a porta serial para depuração\n\n  pinMode(pin_ena, OUTPUT);\n\n  pinMode(pin_dir, OUTPUT);\n\n  pinMode(pin_pul, OUTPUT);\n\n  digitalWrite(pin_ena, enable);\n\n  digitalWrite(pin_dir, direcao);\n\n  digitalWrite(pin_pul, pulso);\n\n  SerialBT.begin(\"Controle remoto\"); // Nome do dispositivo para comunicação BT\n\n}\n\nvoid loop(){\n\n  //Pro calculo de tempo e angulo precisa saber o valor de pul_rev (chaves do hss86)\n\n  while(!flag){\n\n    SerialBT.println(\"Informe valor pul_rev definido nas chaves do HSS86\");\n\n    delay(5000);\n\n    if (SerialBT.available()) { //Verifica se há dados disponíveis na conexão Bluetooth\n\n      comando=SerialBT.readStringUntil('\\n');\n\n      pul_rev=comando.toInt();\n\n      switch(pul_rev){\n\n        case 400:   case 800:   case 1000:  case 1600:\n\n        case 2000:  case 3200:  case 4000:  case 5000:\n\n        case 6400:  case 8000:  case 10000: case 12800:\n\n        case 20000: case 25600: case 40000: case 51200:\n\n            SerialBT.print(\"Pul_rev = \");  SerialBT.println(pul_rev);\n\n            SerialBT.println(\"Envie um comando\");\n\n            flag=1;\n\n        break;\n\n        default:\n\n          SerialBT.println(\"ERRO1. Obs: default=400\");\n\n          break;\n\n      }\n\n    }\n\n  }\n\n  if (SerialBT.available()) {                 // Verifica se há dados disponíveis na conexão Bluetooth\n\n    //Tratar comando recebido\n\n    comando= SerialBT.readStringUntil('\\n');  // Lê o comando enviado pelo dispositivo remoto\n\n    comando.replace(\"\\n\", \"\");                // Remove o caractere '\\n' da string\n\n    letra=comando[0];\n\n    comando.replace(letra, \"\");\n\n    switch(letra[0]){ \n\n      //Direção\n\n      case 'D':\n\n      case 'd':\n\n        if(comando[0]=='0'){direcao=0;}\n\n        else if(comando[0]=='1'){direcao=1;}   \n\n        else{SerialBT.println(\"\\nERRO2\\nValor de direção invalida\");}\n\n        digitalWrite(pin_dir, direcao);\n\n      break;\n\n      //Enable\n\n      case 'E':\n\n      case 'e' :\n\n        if(comando[0]=='0'){enable=0;}\n\n        else if(comando[0]=='1'){enable=1;}   \n\n        else{SerialBT.println(\"\\nERRO3\\nValor de enable invalido\");}\n\n        digitalWrite(pin_ena, enable);\n\n      break;\n\n      //Periodo em us\n\n      case 'P':\n\n      case 'p':\n\n        periodo=comando.toInt();\n\n      break;\n\n      //Numero de passos (Steps)\n\n      case 'S':\n\n      case 's':\n\n        if(comando[0]=='.'){SerialBT.println(\"Modo ligado até comando stop\"); step=1; stay=1;}\n\n        else{step=comando.toInt();}\n\n      break;\n\n      //Angulo de rotação em graus\n\n      case 'A':\n\n      case 'a':\n\n        if(comando[0]=='-'){ang_neg=1; direcao=0; comando.replace(\"-\", \"\");}\n\n        else{ang_neg=0; direcao=1;}     \n\n        digitalWrite(pin_dir, direcao);\n\n        angulo=comando.toInt(); \n\n        step=angulo*(pul_rev)/360;\n\n      break;\n\n      /*\n\n      Não consegui corrigir o tempo, quando envio o comando, a esp desconecta     \n\n      //Tempo de acionamento em s\n\n      case 'T':\n\n      case 't': \n\n        tempo=comando.toInt();\n\n        periodo=tempo*1000000/step;\n\n      break;\n\n      */\n\n      default:\n\n        SerialBT.println(\"\\nERRO4\");\n\n      break;\n\n    }\n\n    if(periodo\u003c5){periodo=6;SerialBT.println(\"\\nERRO5\\nOBS: Periodo mínimo = 5us (fmax=200kHz). Periodo setado para 6us\");}\n\n    SerialBT.printf(\"\\nperiodo(us) = %i\\nstep = %i\\ndirecao = %i\\nenable =  %i\\n\",periodo,step,direcao,enable);\n\n    if(enable){\n\n      SerialBT.println(\"\\nIniciado\");\n\n      for(int i=0; i\u003cstep; i++){\n\n        pulso = !pulso;                                    //inverte o estado da variável\n\n        digitalWrite(pin_pul, pulso);                      //atribui o novo estado à porta\n\n        delayMicroseconds(((   periodo/2  )*2)/2);         //tempo em alta do pulso (divide por 2 e multiplica por 2 pra ter certeza q vai ser inteiro)\n\n        pulso = !pulso;                                    //inverte o estado da variável\n\n        digitalWrite(pin_pul, pulso);                      //atribui o novo estado à porta\n\n        delayMicroseconds(((   periodo/2  )*2)/2);         //tempo em baixa do pulso (divide por 2 e multiplica por 2 pra ter certeza q vai ser inteiro)\n\n        if(stay){i--;}                                     //Decrementa contador, mantem loop infinito\n\n        if (SerialBT.available()) {                        // Verifica se há dados disponíveis na conexão Bluetooth\n\n          //tratamento comando recebido bt\n\n          comando= SerialBT.readStringUntil('\\n');\n\n          comando.replace(\"\\n\", \"\");\n\n          if(comando==\"stop\"){SerialBT.println(\"Forçada parada\"); i=step;stay=0;}\n\n        }\n\n      }\n\n      enable=0;\n\n      //se o angulo foi colocado como negativo, é preciso corrigir o sentido de giro apos comando\n\n      if(ang_neg){direcao=1; ang_neg=0;digitalWrite(pin_dir, direcao);}\n\n    }\n\n    SerialBT.println(\"\\nEnvie um comando\");\n\n  }\n\n}\n\n````\n\n#### Aplicativo 2: Controle remoto\n\n![](content/images/direcao_app2.png)\n\n![](content/images/direcao_app2_comandos.png)\n\nUsaremos:\n-       L (left)\n-       R (right)\n-       S (stop)\n-       0 - 9 + q (speed)\n-       D (close app)\n\n##### Código acionamento (v3)\n\no valor pmin=166 foi obtido por estresse do motor em teste de bancada, maior velocidade para que não perca o passo na velocidade máxima (9)\n\n````\n#include \"BluetoothSerial.h\"\n\nBluetoothSerial SerialBT;\n\n//Definindo pinos\n\nconst int pin_ena = 15;                       //habilita o motor\n\nconst int pin_dir = 2;                        //determina a direção\n\nconst int pin_pul = 4;                        //executa um passo\n\n//Variaveis para leitura mensagem bt\n\nString comando;\n\n//Variáveis para controle do motor\n\nboolean direcao = HIGH;                               // low AH - high H\n\nboolean enable = LOW;\n\nint pmin=166;                                         //Para caso de pul_rev 400 (Experimental)\n\nint velocidade=0;\n\nvolatile boolean pulso = LOW;                         //estado inicial do pulso (borda de decida)\n\nvolatile unsigned long periodo = pmin;                /* microsegundos (periodo minimo)\n\n                                                      Frequencia do driver 200kHz (ou seja, 1 pulso em 1/200k=0.005 ms=5us).\n\n                                                      O ideal seria 2.5 (positivo e negativo), mas vamos trabalhar com margem*/\n\nvoid setup(){\n\n  Serial.begin(9600);                        // Inicializa a porta serial para depuração\n\n  pinMode(pin_ena, OUTPUT);\n\n  pinMode(pin_dir, OUTPUT);\n\n  pinMode(pin_pul, OUTPUT);\n\n  digitalWrite(pin_ena, enable);\n\n  digitalWrite(pin_dir, direcao);\n\n  digitalWrite(pin_pul, pulso);\n\n  SerialBT.begin(\"Controle remoto\"); // Nome do dispositivo para comunicação BT\n\n}\n\nvoid loop(){\n\n  if (SerialBT.available()) {                 // Verifica se há dados disponíveis na conexão Bluetooth\n\n    //Tratar comando recebido\n\n    comando= char(SerialBT.read());                 // Lê o comando enviado pelo dispositivo remoto\n\n    switch(comando[0]){ \n\n      //L (left)\n\n      case 'L':\n\n        enable=1;direcao=0;\n\n        //Serial.print(comando);Serial.println(\" -\u003e d0\");\n\n      break;\n\n      //R (right)\n\n      case 'R':\n\n        enable=1;direcao=1;\n\n        //Serial.print(comando);Serial.println(\" -\u003e d1\");\n\n      break;\n\n      //S(stop)\n\n      case 'S':\n\n      case 'D':\n\n        enable=0;\n\n        //Serial.print(comando);Serial.println(\" -\u003e e0\");\n\n      break;\n\n      //Speed\n\n      case '0': case '1': case '2': case '3':\n\n      case '4': case '5': case '6': case '7':\n\n      case '8': case '9':\n\n        velocidade=comando.toInt();\n\n        periodo=pmin*(1+(10-velocidade)/2);\n\n        //PA com razao sendo metade do periodo minimo\n\n        //Serial.print(comando);Serial.printf(\" p%i\\n\",periodo);\n\n      break;\n\n      case 'q':\n\n        velocidade=10;\n\n        periodo=pmin*(1+(10-velocidade)/2);\n\n        //PA com razao sendo metade do periodo minimo\n\n        //Serial.print(comando);Serial.printf(\" p%i\\n\",periodo);\n\n      break;\n\n      default:\n\n        Serial.println(\"\\nERRO4\");\n\n      break;\n\n    }\n\n    digitalWrite(pin_ena, enable);\n\n    digitalWrite(pin_dir, direcao);\n\n    Serial.print(\" p\");Serial.print(periodo);\n\n    Serial.print(\" d\");Serial.print(direcao);\n\n    Serial.print(\" e\");Serial.println(enable);\n\n    //Serial.printf(\"\\nperiodo(us) = %i\\nstep = %i\\ndirecao = %i\\nenable =  %i\\n\",periodo,step,direcao,enable);\n\n    while(enable \u0026\u0026 comando[0]!='D' \u0026\u0026 comando[0]!='S'){\n\n      pulso = !pulso;                                    //inverte o estado da variável\n\n      digitalWrite(pin_pul, pulso);                      //atribui o novo estado à porta\n\n      delayMicroseconds(((   periodo/2  )*2)/2);         //tempo em alta do pulso (divide por 2 e multiplica por 2 pra ter certeza q vai ser inteiro)\n\n      pulso = !pulso;                                    //inverte o estado da variável\n\n      digitalWrite(pin_pul, pulso);                      //atribui o novo estado à porta\n\n      delayMicroseconds(((   periodo/2  )*2)/2);         //tempo em baixa do pulso (divide por 2 e multiplica por 2 pra ter certeza q vai ser inteiro)\n\n      if (SerialBT.available()) {                        // Verifica se há dados disponíveis na conexão Bluetooth\n\n        comando= char(SerialBT.read());\n\n      }\n\n    }\n\n  }\n\n}\n\n````\n\n# 2. Controle remoto\n\n## 2.1. Possibilidades\n\n1. Bluetooth: O Bluetooth é uma tecnologia sem fio de curto alcance que é amplamente utilizada em dispositivos móveis, como smartphones e fones de ouvido. É relativamente fácil de configurar e oferece uma boa taxa de transferência de dados para distâncias de até 10 metros em ambientes internos.\n2. WiFi: O WiFi é um protocolo de comunicação sem fio de médio alcance que é amplamente utilizado em redes domésticas e empresariais. É mais complexo de configurar do que o Bluetooth, mas oferece taxas de transferência de dados mais altas e uma cobertura de alcance mais ampla para distâncias de até cerca de 50 metros em ambientes internos.\n3. Zigbee: Zigbee é um protocolo de comunicação sem fio de curto alcance que é frequentemente usado em sistemas de automação residencial e industrial. É especialmente adequado para aplicações que exigem baixo consumo de energia e comunicação confiável para distâncias de até cerca de 10 metros.\n4. LoRa: LoRa é um protocolo de comunicação de longo alcance que é adequado para aplicações que exigem cobertura em grandes áreas. Embora a distância máxima de comunicação possa ser superior a vários quilômetros em condições ideais, a taxa de transferência de dados é relativamente baixa. Portanto, é mais adequado para aplicações que exigem comunicação de baixa taxa de dados, como monitoramento de sensores remotos.\n\n### 2.1.1. Phantom 4\n\n![](content/images/direcao_phantom4.png)\n\nO controle remoto do Phantom 4 utiliza uma tecnologia de comunicação proprietária da DJI, chamada de Lightbridge, que não é diretamente compatível com microcontroladores convencionais, como o Arduino\n\n### 2.1.2. Arduino + módulo WiFi\n\n![](content/images/Arduino_WiFi.png)\n\n![](content/images/Arduino_WiFi2.png)\n\n### 2.1.3. ESP para Raspberry (SPI)\n\nUma opção seria a leitura do controle remoto  feita pela raspberry (controlador) tal que esta envie os sinais para esp (periférico) que controlará o driver\n\n#### Estudando Comunicação SPI\n\nNa comunicação serial síncrona introduzimos o conceito de mestre - escravo (controlador - periférico), com apenas um controlador. Ou seja, um mesmo sensor (periférico) não pode estar em duas redes distintas, cada uma com um mestre diferente.\n\nAlém disso, os barramentos são unidirecionais, ou seja, os sinais são definidos somente como enviado ou somente como recebido. Mas é possível envio e recebimento de sinal de forma simultânea (por barramentos diferentes)\n\n![](content/images/direcao_SPI.png)\n\n![](content/images/direcao_SPI2.png)\n\nPossível atingir velocidades maiores de comunicação porque há pouca deformação do sinal utilizando dois canais separados\n\n##### Exemplo ligação\n\n![](content/images/direcao_SPI3.png)\n\nNo SS, o dispositivo é selecionado quando este pino se encontra em nível baixo\nMISO: serial data out (SDO)\nMOSI: serial data in (SDI)\n\n![](content/images/direcao_SPI4.png)\n\n![](content/images/direcao_SPI5.png)\n\n#### ESP32 (portas spi)\n\n![](content/images/direcao_SPI6.png)\n\n![](content/images/direcao_SPI7.png)\n\nSP0 and SP1 are used internally to communicate with the built-in flash memory, and you should not use them for other tasks.\n\n### !2.1.4. ESP para Raspberry (CAN)\n\n#### Protocolo CAN\n\n##### Características gerais           \n\n![](content/images/direcao_CAN.png)\n\nProtocolo CAN (Controller Area Network) é um protocolo de comunicação serial simultânea:\n-       transmite dados a uma taxa de até 1 Mbps em barramentos de até 40 metros;\n-       síncrono: sincronização no início de cada mensagem enviada ao barramento;\n-       multicast: todas as mensagens são recebidas por todos os módulos da rede;\n-       multi-mestre: todos módulos podem ser mestre ou escravo em determinado momento;\n-       Suporta até 120 nós por barramentos;\n-       CSMA/CD with NDA: caso duas mensagens sejam enviadas ao barramento ao mesmo instante, o módulo de menor prioridade cessará sua transmissão e o de maior continuará enviando sua mensagem, sem ter que reiniciá-la;\n-       NRZ (Non Return to Zero): cada bit transmitido representa efetivamente um dado;\n-       Protocolo regulado: ISO 11898\n-       A velocidade de transmissão dos dados é proporcional ao comprimento do barramento;\n\n![](content/images/direcao_CAN2.png)\n\nO protocolo foi desenvolvido pela BOSCH\n\n##### Configuração dos fios\n\nHá três formas de construir o barramento (bus):\n-       2 fios (dados: CAN H - high e CAN L - low),\n-       4 fios (dado + VCC e GND, para alimentação dos blocos subsequentes)\n-       1 fio (Somente 1 fio de dado: CAN).\n\nO barramento é classificado como Par Trançado Diferencial (para 2 e 4 fios): os dados são interpretados pela análise da diferença de potencial entre os fios CAN H e CAN L, por isso não necessita blindagem (pois, caso haja efeito de campo externo, afetará ambos os sinais)\n\nPara velocidades de comunicação acima de 250 kbit/s, é recomendado cabo em par trançado para a minimização de ruídos. É recomendado um resistor externo de 120 Ω/0,25 W para a rede CAN. A secção transversal de cada um dos fios deve ser de no mínimo 0,35mm²\n\n##### Formato dos dados\n\nOs dados são representados por bits recessivos e dominantes. O bit zero é dominante.  Após enviar um bit, cada módulo analisa o barramento e verifica se outro módulo na rede o sobrescreveu.\n\n![](content/images/direcao_CAN3.png)\n\n##### Formatos de mensagem:\n\n-       CAN 2.0A (padrão): Mensagens com identificador de 11 bits, até 2048 mensagens\n\n![](content/images/direcao_CAN4.png)\n\n![](content/images/direcao_CAN5.png)\n\n-       CAN 2.0B (estendido): identificador de 29 bits, até  5,3*10⁶ de mensagens, entretanto há aumento no tempo de transmissão de cada mensagem\n\n![](content/images/direcao_CAN6.png)\n\n![](content/images/direcao_CAN7.png)\n\n##### Tipos de mensagens:\n\n-       Frame de Dados: Contém os dados do emissor para o(s) receptor(es);\n\n![](content/images/direcao_CAN8.png)\n\n-       Frame Remota: É uma solicitação de dados partindo de um dos nós;\n\n![](content/images/direcao_CAN9.png)\n\n-       Frame de Erro: É um frame enviado por qualquer um dos nós ao identificar um erro no barramento e pode ser detectado por todos os nós;\n\n![](content/images/direcao_CAN10.png)\n-       Frame de sobrecarga: Serve para retardar o tráfego no barramento devido à sobrecarga de dados ou atraso em um ou mais nós.\n\n![](content/images/direcao_CAN11.png)\n\n##### Transceiver (MCP2515 -  Controlador CAN Stand-Alone com Interface SPI)\n\n![](content/images/direcao_MCP2515.png)\n\nPor que usar MCP2515 se a ESP32 ja tem uma porta CAN interna? Existem aplicações que requerem mais de uma porta CAN, e o único recurso do ESP32 aplicável para isso é a interface SPI. Na verdade, hipoteticamente, você pode adicionar até seis portas CAN controladas por SPI ao ESP32\n\n![](content/images/direcao_MCP2515_pinout.png)\n\n# 3. Encoder\n\n![](content/images/direcao_encoder.png)\n\n## 3.1. Possibilidades\n\n### 3.1.1. Encoder externo\n\n(Pegar os dados diretamente do motor)\n\nteria que fazer uma redução com faixas escuras delimitadas para leitura por esse sensor. Ele envia luz e atua conforme a reflexão dela dada a sua reflexão.\n\n![](content/images/direcao_encoder2.png)\n\nFunciona como um amplificador. Mudando as resistências, altera a faixa que ele considera alta(3,3V) e baixa(0V). Assim, alteramos a sensibilidade do sensor (luz)\n\n![](content/images/direcao_encoder3.png)\n\n### 3.1.2. Software HSS86\n\n(Pegar dos dados a partir do driver HSS86)\n\n![](content/images/direcao_soft_HSS86.png)\n\n![](content/images/direcao_soft_HSS86_2.png)\n\n![](content/images/direcao_soft_HSS86_3.png)\n\n![](content/images/direcao_soft_HSS86_4.png)\n\n### 3.1.3. Encoder do próprio motor\n\n#### Leitura encoder\n\nTestes para p=1000us, pelo osciloscópio temos que o período do motor equivale a 400us para essa aplicação.\n\n![](content/images/direcao_teste_encoder.jpg)\nSinais ea+ e eb+ são defasados em 90 (sentido horário d1)\n\n![](content/images/direcao_teste_encoder2.jpg)\nSinais ea+ e eb+ são defasados em 90 (sentido anti horário d0)\n\n![](content/images/direcao_teste_encoder3.jpg)\nSinais ea+ e ea- são opostos\n\n#### ESP32 (AttachInterrupt)\n\n![](content/images/direcao_pinout_attach.png)\n\nfunção _attachInterrupt_, cujo protótipo é _attachInterrupt(GPIOPin, ISR, Mode)_. Onde:\n\n●     **GPIOPin:** número do GPIO que quer monitorar utilizando interrupção externa;\n\n●     **ISR:** nome da função a ser chamada na hora de tratar a interrupção;\n\n●     **Mode:** modo da interrupção (LOW, HIGH, RISING, FALLING ou CHANGE).\n\nNo ESP32, há os seguintes modos de interrupção suportados para os GPIOs:\n\n●     **FALLING:** um modo que faz ser gerada uma interrupção quando um GPIO vai do nível alto (3V3) para nível baixo (0V). Ou seja, interrupção gerada na transição de nível alto para baixo;\n\n●     **RISING:** um modo que faz ser gerada uma interrupção quando um GPIO vai do nível baixo (0V) para nível alto (3V3). Ou seja, interrupção gerada na transição de nível baixo para alto;\n\n●     **LOW:** um modo que faz ser gerada uma interrupção gerada quando o GPIO está em nível baixo;\n\n●     **HIGH:** um modo que faz ser gerada uma interrupção gerada quando o GPIO está em nível alto;\n\n●     **CHANGE:** um modo que faz ser gerada uma interrupção quando há qualquer transição de nível no GPIO. Ou seja, tanto de nível baixo para alto quanto de nível alto para baixo.\n\n#### *Código encoder (falta testar)\n````\nconst int pinA = 34;\n\nconst int pinB = 35;\n\nconst int debounceDelay = 50;\n\nvolatile int stateA, stateB, prevStateA, prevStateB;\n\nvolatile int counter = 0;\n\nunsigned long lastDebounceTime = 0;\n\nvoid IRAM_ATTR isrA() {\n\n  stateA = digitalRead(pinA);\n\n  stateB = digitalRead(pinB);\n\n  if (millis() - lastDebounceTime \u003e debounceDelay) {\n\n    if (prevStateA == LOW \u0026\u0026 stateA == HIGH) {\n\n      if (stateB == LOW) {\n\n        counter++;\n\n      } else {\n\n        counter--;\n\n      }\n\n    } else if (prevStateA == HIGH \u0026\u0026 stateA == LOW) {\n\n      if (stateB == LOW) {\n\n        counter--;\n\n      } else {\n\n        counter++;\n\n      }\n\n    }\n\n    prevStateA = stateA;\n\n    prevStateB = stateB;\n\n    lastDebounceTime = millis();\n\n  }\n\n}\n\nvoid IRAM_ATTR isrB() {\n\n  stateA = digitalRead(pinA);\n\n  stateB = digitalRead(pinB);\n\n  if (millis() - lastDebounceTime \u003e debounceDelay) {\n\n    if (prevStateB == LOW \u0026\u0026 stateB == HIGH) {\n\n      if (stateA == LOW) {\n\n        counter--;\n\n      } else {\n\n        counter++;\n\n      }\n\n    } else if (prevStateB == HIGH \u0026\u0026 stateB == LOW) {\n\n      if (stateA == LOW) {\n\n        counter++;\n\n      } else {\n\n        counter--;\n\n      }\n\n    }\n\n    prevStateA = stateA;\n\n    prevStateB = stateB;\n\n    lastDebounceTime = millis();\n\n  }\n\n}\n\nvoid setup() {\n\n  pinMode(pinA, INPUT);\n\n  pinMode(pinB, INPUT);\n\n  attachInterrupt(digitalPinToInterrupt(pinA), isrA, CHANGE);\n\n  attachInterrupt(digitalPinToInterrupt(pinB), isrB, CHANGE);\n\n  Serial.begin(9600);\n\n}\n\nvoid loop() {\n\n  Serial.println(counter);\n\n  delay(100);\n\n}\n\n## 3.2. Dual core ESP32\n\nPara leitura do encoder e controle do motor simultâneo serão utilizados os 2 processadores da esp\n\n### *Código Multitask (falta testar)\n\n#include \u003cBluetoothSerial.h\u003e\n\nBluetoothSerial SerialBT;\n\nTaskHandle_t TaskBluetooth;\n\nTaskHandle_t TaskSerial;\n\n///////////////////////////////////Inicialização tarefa 1: Encoder ////////////////////////////////////////////\n\n//Definindo pinos\n\nconst int pin_ena = 15;                        //habilita o motor\n\nconst int pin_dir = 5;                        //determina a direção\n\nconst int pin_pul = 4;                        //executa um passo\n\n//Variaveis para leitura mensagem bt\n\nString comando;\n\nString letra;\n\n//Variáveis para controle do motor\n\nboolean direcao = HIGH;                       // low AH - high H\n\nboolean enable = LOW;\n\nboolean pulso = LOW;                          //estado inicial do pulso (borda de decida)\n\nint step = 4000;                              //Conta x pulsos\n\nint periodo = 6;                              /* microsegundos (periodo minimo)\n\n                                              Frequencia do driver 200kHz (ou seja, 1 pulso em 1/200k=0.005 ms=5us).\n\n                                              O ideal seria 2.5 (positivo e negativo), mas vamos trabalhar com margem*/\n\n//Variáveis para calculo/conversão\n\nint tempo;\n\nint angulo;\n\nint pul_rev;\n\n//Flags intermediarias\n\nint ang_neg=0;                                 //flag sinal angulo\n\nint flag=0;                                    //flag valor pul_rev recebido\n\nint stay=0;                                    //flag comando permanecer ligado\n\nvoid setup() {\n\n  Serial.begin(9600);\n\n  pinMode(pin_ena, OUTPUT);\n\n  pinMode(pin_dir, OUTPUT);\n\n  pinMode(pin_pul, OUTPUT);\n\n  digitalWrite(pin_ena, enable);\n\n  digitalWrite(pin_dir, direcao);\n\n  digitalWrite(pin_pul, pulso);\n\n  SerialBT.begin(\"Controle remoto\"); // Nome do dispositivo para comunicação BT\n\n  xTaskCreatePinnedToCore(\n\n    TaskBluetoothCode,\n\n    \"Bluetooth\",\n\n    100000,\n\n    NULL,\n\n    1,\n\n    \u0026TaskBluetooth,\n\n    0\n\n  );\n\n  xTaskCreatePinnedToCore(\n\n    TaskSerialCode,\n\n    \"Serial\",\n\n    10000,\n\n    NULL,\n\n    1,\n\n    \u0026TaskSerial,\n\n    1\n\n  );\n\n}\n\nvoid TaskBluetoothCode(void *pvParameters) {\n\n  while (1) {\n\n    while(!flag){\n\n      SerialBT.println(\"Informe valor pul_rev definido nas chaves do HSS86\");\n\n      delay(5000);\n\n        if (SerialBT.available()) { //Verifica se há dados disponíveis na conexão Bluetooth\n\n          comando=SerialBT.readStringUntil('\\n');\n\n          pul_rev=comando.toInt();\n\n          switch(pul_rev){\n\n            case 400:   case 800:   case 1000:  case 1600:\n\n            case 2000:  case 3200:  case 4000:  case 5000:\n\n            case 6400:  case 8000:  case 10000: case 12800:\n\n            case 20000: case 25600: case 40000: case 51200:\n\n                SerialBT.print(\"Pul_rev = \");  SerialBT.println(pul_rev);\n\n                SerialBT.println(\"Envie um comando\");\n\n                flag=1;\n\n                break;\n\n            default:\n\n              SerialBT.println(\"ERRO1. Obs: default=400\");\n\n              break;\n\n          }\n\n        }\n\n    }\n\n    if (SerialBT.available()) {\n\n      comando= SerialBT.readStringUntil('\\n');  // Lê o comando enviado pelo dispositivo remoto\n\n      comando.replace(\"\\n\", \"\");                // Remove o caractere '\\n' da string\n\n      letra=comando[0];\n\n      comando.replace(letra, \"\");\n\n      switch(letra[0]){ \n\n        //Direção\n\n        case 'D':\n\n        case 'd':\n\n          if(comando[0]=='0'){SerialBT.println(\"mudei direção pra 0\");direcao=0;}\n\n          else if(comando[0]=='1'){SerialBT.println(\"mudei direção pra 1\"); direcao=1;}   \n\n          else{SerialBT.println(\"ERRO2\");}\n\n          SerialBT.print(\"dir = \"); SerialBT.println(direcao);\n\n          digitalWrite(pin_dir, direcao);\n\n        break;\n\n        //Enable\n\n        case 'E':\n\n        case 'e' :\n\n          if(comando[0]=='0'){enable=0;}\n\n          else if(comando[0]=='1'){enable=1;}   \n\n          else{SerialBT.println(\"ERRO3\");}\n\n          digitalWrite(pin_ena, enable);\n\n          SerialBT.print(\"ena = \"); SerialBT.println(enable);\n\n        break;\n\n        //Periodo em us\n\n        case 'P':\n\n        case 'p':\n\n          periodo=comando.toInt();  //forçar que o numero seja par\n\n          SerialBT.print(\"periodo (us) = \"); SerialBT.println(periodo);\n\n        break;\n\n        //Numero de passos (Steps)\n\n        case 'S':\n\n        case 's':\n\n          if(comando[0]=='.'){SerialBT.println(\"Ficará ligado até comando stop\"); step=1; stay=1;}\n\n          else{\n\n            step=comando.toInt();\n\n            SerialBT.print(\"step = \");   SerialBT.println(step);\n\n          }\n\n        break;\n\n        //Angulo de rotação em graus\n\n        case 'A':\n\n        case 'a':\n\n          SerialBT.print(\"angulo = \");\n\n          if(comando[0]=='-'){ang_neg=1; direcao=0; comando.replace(\"-\", \"\");SerialBT.print(\"-\");}\n\n          else{ang_neg=0; direcao=1; SerialBT.print(\"+\");}     \n\n          digitalWrite(pin_dir, direcao);\n\n          angulo=comando.toInt(); \n\n          step=angulo*(pul_rev)/360;\n\n          SerialBT.println(angulo);\n\n        break;\n\n        default:\n\n          SerialBT.println(\"ERRO4\");\n\n        break;\n\n      }\n\n      if(periodo\u003c5){periodo=6;SerialBT.println(\"ERRO5\"); SerialBT.println(\"OBS: Periodo mínimo = 5us (fmax=200kHz). Periodo setado para 6us\");}\n\n      else{SerialBT.println(\"frequencia dentro da permitida\u003e5us\");}\n\n      SerialBT.print(\"\\nperiodo (us)= \");  SerialBT.println(periodo);\n\n      SerialBT.print(\"step = \");  SerialBT.println(step);\n\n      SerialBT.print(\"direcao = \");  SerialBT.println(direcao);\n\n      SerialBT.print(\"enable = \");  SerialBT.println(enable);\n\n      if(enable){\n\n        SerialBT.println(\"Iniciado\");\n\n        for(int i=0; i\u003cstep; i++){\n\n          pulso = !pulso;                                    //inverte o estado da variável\n\n          digitalWrite(pin_pul, pulso);                      //atribui o novo estado à porta\n\n          delayMicroseconds(((   periodo/2  )*2)/2);         //tempo em alta do pulso (divide por 2 e multiplica por 2 pra ter certeza q vai ser inteiro)\n\n          pulso = !pulso;                                    //inverte o estado da variável\n\n          digitalWrite(pin_pul, pulso);                      //atribui o novo estado à porta\n\n          delayMicroseconds(((   periodo/2  )*2)/2);         //tempo em baixa do pulso (divide por 2 e multiplica por 2 pra ter certeza q vai ser inteiro)\n\n          if(stay){i--;}\n\n          if (SerialBT.available()) {                        // Verifica se há dados disponíveis na conexão Bluetooth\n\n            comando= SerialBT.readStringUntil('\\n');         // Lê o comando enviado pelo dispositivo remoto\n\n            comando.replace(\"\\n\", \"\");                       // Remove o caractere '\\n' da string\n\n            if(comando==\"stop\"){SerialBT.println(\"Forçada parada\"); i=step;stay=0;}\n\n          }\n\n        }\n\n        enable=0;\n\n        //se o angulo foi colocado como negativo, é preciso corrigir o sentido de giro apos comando\n\n        if(ang_neg){direcao=1; ang_neg=0;digitalWrite(pin_dir, direcao);SerialBT.println(\"Angulo negativo, direçao resetada\");}\n\n        SerialBT.println(\"Comando recebido: \" + comando);\n\n        SerialBT.println(\"\\nEnvie um comando\");\n\n      }\n\n    }\n\n    // Adicione aqui qualquer outra lógica relacionada à tarefa Bluetooth\n\n    vTaskDelay(100 / portTICK_PERIOD_MS);\n\n  }\n\n}\n\nvoid TaskSerialCode(void *pvParameters) {\n\n  while (1) {\n\n    Serial.println(\"oi mundo\");\n\n    // Adicione aqui qualquer outra lógica relacionada à tarefa Serial\n\n    vTaskDelay(1000 / portTICK_PERIOD_MS);\n\n  }\n\n}\n\nvoid loop() {}\n````\n\n# 4. Bibliografia\n\n[1]  [Dados motor de passo NEMA 34](https://www.fernandok.com/)\n[2]  [Sinalização erro LED HSS86]([HSS86 and 2HSS86H Closed Loop Drivers (cnczone.com)](https://www.cnczone.com/forums/servo-motors-drives/356990-software.html))\n[3]  [Comunicação CAN na ESP32 ](https://www.fernandok.com/2018/07/protocolo-can-yes-we-can.html)\n[4]  [Uso software HSS86](https://www.youtube.com/watch?v=2x_IKvZJIPQ)\n[5]  [Projeto encoder com arduino](https://easytromlabs.com/arduino/arduino-lab-09-leitura-de-um-encoder-industrial-heidenhain-com-o-arduino/)\n[6]  [Uso de interrupções na ESP32]([Uso de interrupções externas com ESP32 - MakerHero](https://www.makerhero.com/blog/uso-de-interrupcoes-externas-com-esp32/)\n[7]  [Introdução geral sobre rede CAN](http://www.alexag.com.br/Artigos/SAE2002.pdf)\n[8]  [Tipos de CAN (low speed, high speed and FD)](https://dewesoft.com/blog/what-is-can-bus)\n\n\u003c!--\nMotor DC 4000 RPM redução 1:8 encoder 15 passos, plataforma: Arduino\n![[esquema_direcao.jpg]]\n--\u003e","lastmodified":"2023-06-15T12:59:49.387182869Z","tags":null},"/FESiar%C3%A1":{"title":"Fórmula-E Siará Wiki","content":"\n\u003e[!tip] Então, você quer saber mais sobre o Fórmula-E Siará?\n\nNossa equipe é formada por alunos de diferentes cursos de engenharia e áreas afins, que trabalham em conjunto para criar um carro inovador, eficiente e competitivo.\n\nNeste site, você vai conhecer um pouco mais sobre o nosso projeto e as principais características do nosso carro. Vamos apresentar os sistemas que compõem o veículo e os desafios que enfrentamos para desenvolvê-los. Esperamos que você se inspire com a nossa história e se apaixone pelo Fórmula-E Siará!\n\n## Chassi\n\nO chassi é a estrutura que sustenta todos os componentes do veículo. Ele deve ser leve, resistente e rígido o suficiente para garantir a segurança dos ocupantes e o desempenho dinâmico do carro. O nosso chassi é feito de tubos de aço (SAE 1020) soldados com o processo MIG/MAG, realizado por alunos da UFPB. Ele possui uma célula de sobrevivência para o piloto, com cintos de segurança de cinco pontos e uma barra antivolta. O chassi também incorpora pontos de fixação para os sistemas de suspensão, freio, direção, propulsão e baterias.\n\n## Suspensão\n\nA suspensão é o sistema responsável por conectar as rodas ao chassi e absorver as irregularidades do solo. Ela deve proporcionar estabilidade, conforto e aderência ao veículo. A nossa suspensão é do tipo duplo A (double wishbone), com quatro braços triangulares por roda, que permitem ajustar a geometria da suspensão de acordo com as condições da pista. A suspensão também conta com amortecedores a gás e barras estabilizadoras, que controlam o movimento vertical e lateral do carro.\n\n## Sistema de Freio\n\nO sistema de freio é o sistema responsável por reduzir a velocidade ou parar o veículo. Ele deve ser confiável, eficaz e modulável. O nosso sistema de freio é composto por quatro discos ventilados de aço inoxidável, acionados por pinças de quatro pistões cada. O sistema também possui um cilindro mestre duplo com um regulador de pressão entre os circuitos dianteiro e traseiro, que permite ajustar o equilíbrio de frenagem entre as rodas. Além disso, o sistema conta com um dispositivo anti-bloqueio (ABS), que evita que as rodas travem em situações de emergência.\n\n## Sistema de Propulsão (Powertrain)\n\nO sistema de propulsão é o sistema responsável por gerar e transmitir a potência do motor para as rodas. Ele deve ser potente, eficiente e durável. O nosso sistema de propulsão é baseado em um motor elétrico síncrono de ímã permanente, que produz 80 kW (109 CV) de potência máxima e 220 Nm (22,4 kgf.m) de torque máximo. O sistema também possui uma transmissão por corrente e uma embreagem centrífuga, que acopla ou desacopla o motor das rodas traseiras\n\n### Inversor de Frequência\n\nO [Inversor de Frequência](notes/elétrica/Inversor%20de%20Frequência) é o dispositivo responsável por controlar a velocidade do motor elétrico, variando a frequência e a tensão que é fornecida a ele. Ele converte a corrente alternada fixa da rede elétrica em uma corrente alternada variável, usando uma técnica chamada modulação por largura de pulso (PWM). O inversor de frequência permite ajustar a velocidade do motor de acordo com a demanda da operação, otimizando o consumo de energia e o desempenho do veículo. O nosso inversor de frequência é um modelo compacto e robusto, que possui proteções contra sobrecarga, curto-circuito e sobretensão. Ele também possui uma interface de comunicação com o sistema de eletrônica embarcada, que permite monitorar e controlar os parâmetros do motor.\n\n### Baterias\n\nO módulo de [baterias](notes/elétrica/Baterias) é responsável por monitorar e proteger o pacote de baterias que alimenta o motor elétrico. O pacote é composto por 120 células de íons de lítio, conectadas em série e paralelo, que fornecem uma tensão nominal de 400 V e uma capacidade de 15 Ah \\[[4.1](https://blog.kalatec.com.br/inversor-de-frequencia/))]. O módulo de baterias mede a tensão, a corrente e a temperatura de cada célula, além do estado de carga (SOC) e do estado de saúde (SOH) do pacote. O módulo também controla os relés e os fusíveis que isolam o pacote da rede elétrica do veículo em caso de falha ou emergência. O módulo ainda envia dados para o sistema de telemetria e para o inversor de frequência, que usa essas informações para otimizar o controle do motor.\n\n\n## Eletrônica\n\nA eletrônica é o conjunto de circuitos e componentes que gerenciam e controlam os diversos sistemas do veículo. Ela é responsável por coletar, processar e transmitir dados e sinais entre os sensores, atuadores, dispositivos de entrada e saída e o sistema de telemetria. A nossa eletrônica é dividida em módulos que se comunicam por meio de um barramento CAN (Controller Area Network), que garante uma alta velocidade e confiabilidade na troca de informações. Alguns dos módulos que compõem a nossa eletrônica são:\n\n### Direção\n\nO módulo de [direção elétrica](Direção.md) é responsável por controlar o sistema de direção elétrica assistida (EPS), que auxilia o piloto na condução do veículo. O EPS consiste em um motor elétrico acoplado à coluna de direção, que aplica um torque proporcional à força exercida pelo piloto no volante. O módulo de direção recebe o sinal do sensor de torque no volante e envia um comando para o motor do EPS, ajustando o nível de assistência conforme a velocidade do veículo. O módulo também monitora a temperatura e a corrente do motor do EPS, além de enviar dados para o sistema de telemetria.\n\n## Telemetria\n\nA telemetria é o sistema responsável por transmitir e receber dados entre o veículo e uma estação base. Ela permite acompanhar em tempo real o funcionamento e o desempenho do veículo durante os testes e as provas da competição. A nossa telemetria usa um transceptor sem fio que opera na faixa de 2,4 GHz, com uma taxa de transmissão de 250 kbps. O transceptor se comunica com um computador na estação base, que exibe os dados em uma interface gráfica desenvolvida pela equipe. A telemetria também permite enviar comandos para o veículo, como ligar ou desligar sistemas ou alterar parâmetros de controle.\n\nConsiderando essenciais os sentores: IMU, GPS, de velocidade das rodas, LIDAR e câmeras. Freio, propulsão, suspensão → serão analisados e incluídos futuramente. Então só vamos trabalhar com dados dos primeiros tanto para transmitir tanto quanto para dar entrada no controle. \n\nPara o sensor de RPM a melhor solução é fazer como em carros comerciais, usando o sensor ABS. Que se trata de um sensor indutivo acoplado mirando os dentes da engrenagem do eixo da roda, possibilitando haver uma boa resolução em velocidades altas ou baixas, não pode ser confundido com a saída do eixo do motor, em que pode haver uma redução dele para as rodas. Este sensor mede o RPM real das rodas, não a velocidade do motor.\n\nSobre a Inter comunicação(interna), todos subsistemas se comunicarão com o protocolo CAN, assim como é feito em modelos comerciais e carros de maior porte. Será um sistema híbrido com vários controladores e sensores, independentes, mas trabalhando em conjunto com o computador principal, o qual processa vídeo e envia dados para a telemetria.\n\n\n\n\u003e[!INFO] Veja também sobre:\n\u003e\n\u003e 🔗[Escolha de sensores](notes/elétrica/Escolha%20de%20sensores.md) \u003cbr/\u003e\n\u003e 🔗 [Simulador](notes/telemetria/Simulador.md) \u003cbr/\u003e\n\u003e 🔗  [Controle manual à distância](notes/elétrica/Controle%20manual%20à%20distância) \u003cbr/\u003e\n","lastmodified":"2023-06-15T12:59:49.387182869Z","tags":null},"/notes/el%C3%A9trica/Balanceamento-de-Baterias":{"title":"Balanceamento de Baterias","content":"","lastmodified":"2023-06-15T12:59:49.435182576Z","tags":null},"/notes/el%C3%A9trica/Baterias":{"title":"Baterias","content":"\n# Objetivos e Desafios\n\nA Bateria precisa ter uma capacidade de carga razoável\nA Bateria precisa ser carregada com desgaste mínimo\nPrecisamos de [[notes/elétrica/Battery Managment System|monitoriamento]] constante (pra reduzir o desgaste e manter segurança química da bateria)\n# Como Estamos?\nAtualmente usamos 4 baterias de chumbo-ácido de 12V em série, com capacidade individual de 115Ah\n# Futuro\nSubstituição por baterias de [Íon de Lítio](notes/elétrica/Estudo%20de%20Baterias%20Substitutivas.md)\n","lastmodified":"2023-06-15T12:59:49.435182576Z","tags":null},"/notes/el%C3%A9trica/Battery-Managment-System":{"title":"Battery Managment System","content":"\nUm sistema de gerenciamento de bateria (**battery management system**) é qualquer sistema eletrônico que gerencie uma bateria recarregável (seja uma única célula ou um conjunto), protegendo-a de surtos de corrente, monitorando seu estado, calculando dados secundários, enviar esses dados, controlar o ambiente na qual ela se encontra e/ou [[notes/elétrica/Balanceamento de Baterias|balanceando-a]].\n\nA [battery pack](https://en.wikipedia.org/wiki/Battery_pack \"Battery pack\") built together with a battery management system with an external communication [data bus](https://en.wikipedia.org/wiki/Bus_(computing) \"Bus (computing)\") is a [smart battery pack](https://en.wikipedia.org/wiki/Smart_battery_pack \"Smart battery pack\"). A smart battery pack must be charged by a [smart battery charger](https://en.wikipedia.org/wiki/Smart_battery_charger \"Smart battery charger\").","lastmodified":"2023-06-15T12:59:49.435182576Z","tags":null},"/notes/el%C3%A9trica/CANopen":{"title":"CANopen","content":"\n# Introdução\nCANopen é um protocolo de comunicação de rede amplamente utilizado na indústria, especialmente na automação industrial. Ele foi desenvolvido como uma forma padronizada de comunicação entre dispositivos eletrônicos em uma rede [CAN (Controller Area Network)](https://en.wikipedia.org/wiki/CAN_bus).\n\n# Funcionamento\nO funcionamento do CANopen é baseado fundamentalmente no protocolo CAN, mas inclui uma camada de abstração adicional que permite uma comunicação mais flexível e robusta entre os dispositivos industriais. Ele inclui um conjunto de mensagens padronizadas que podem ser usadas para enviar e receber dados, além de mecanismos de gerenciamento de rede e diagnóstico.\n\nA implementação do CANopen envolve a conexão de dispositivos eletrônicos compatíveis através de uma rede CAN física, usando cabos e conectores padronizados. Cada dispositivo na rede é atribuído a um endereço único e pode ser configurado para enviar ou receber mensagens específicas. Um gerenciador de rede então pode ser usado para configurar e monitorar os dispositivos (como sensores e o próprio inversor de frequência) na rede, bem como para diagnosticar eventuais problemas.","lastmodified":"2023-06-15T12:59:49.435182576Z","tags":null},"/notes/el%C3%A9trica/Controle-manual-%C3%A0-dist%C3%A2ncia":{"title":"Controle manual à distância","content":"\nPara controle do carro no simulador ou mesmo fisicamente, existe a opção de usar um controle especializado, como os drones possuem, entretanto, havendo boa infraestrutura de telemetria podemos usar alguns controles mais simples como teclado ou mesmo um gamepad, havendo confiabilidade e mecanismos de segurança. Nesse sentido temos o módulo `ds4input` que recebe entrada de um controle de PS4 e transmite via tópicos do ROS para controle do carro. \n\nNo momento faça: `ros2 run ds4input main`\n\nO código escreverá a mensagem AckermannSteeringStamped no tópico `/cmd`\nApós abrir o simulador apenas colocar em modo manual, e a entrada via controle funciona, não mexer com comandos de velocidade do launcher usando o controle, até o momento a integração não é completa.","lastmodified":"2023-06-15T12:59:49.435182576Z","tags":null},"/notes/el%C3%A9trica/Escolha-de-sensores":{"title":"Escolha de sensores","content":"\nOK\n- IMU MPU 9250, um nível acima do mais básico, MPU6050\n- GPS Ublox neo 6m / m8n\n- RPM: simples encoder óptico(incremental), pode até ser DIY impresso 3D, no caso mais simples de acoplar sendo só um disco que vai ser lido pelo encoder de quadratura. Senão temos duas opções, usar um encoder óptico rotativo direto na roda/eixo ou com uma redução com uma constante alterada em software.\n- Transmissão de dados: par de ESP32 com anteninha ou um microcontrolador com wifi mais forte.\n\nBOM\n- IMU: Bosch BNO055. Justificativa → É um pouco melhor que o 9250, mas aparentemente incrível. O BNO tem um algoritmo de fusão sensorial que pode ajudar com a parte do GPS, removendo peso do controlador principal. Ganha em alguns aspectos do 9250\n- GPS: SparkFun GPS-RTK2 Board - ZED-F9P → 0,05 m/s, dobro do ultimo, ODR de 8 a 25 Hz, dependendo do modo. Aparentemente 1,5m de erro, não fica muito claro na datasheet. Tem dois tipos de medidas o PVT, aparentemente o padrão de todos, de onde eu tirei os 1,5m. Também tem o RTK, que pode ser preciso por até 10cm, supostamente segundo a datasheet, mas esse método é mais preciso mesmo. Precisa importar.\n- Sensor indutivo industrial, simples, a ser acoplado na engrenagem do eixo da roda, o que varia vai ser a frequência e distância de ativação.\n- Transmissão de dados: ZigBee/LoRa\n\nExcelente\n- IMU, GPS, barômetro: VectorNav VN-300, é um INU, intertial navigation system. Possui todas as funções, é só um dos modelos usados para máquinas pesadas de campo, ou mesmo navios, é um grande exagero, contudo, é mais que excelente.\n- RPM: sensor indutivo comercial especificamente para carros.\n- Transmissão de dados: HolyBro SiK Telemetry Radio V3, similar ao do PixHawk4\n\nTransmissão de dados\nAlgumas situações são possíveis, considerando que serão transmitidos os dados dos sensores apenas, sem câmeras ou LIDAR, devido ao grande volume de dados, importando mais o controle e condições de operação do carro\n- para um setup mais simples, um ESP32 ou mesmo o Wi-Fi do Raspberry Pi podem ser suficientes, unidos de um bom roteador, sendo possível andar um pouco apenas para tester simples. \n- Outra opção é usar um módulo 4G no Raspberry Pi, no entanto acrescenta complexidade. \n- Há módulos de rádio LoRa que alcançam quilometros de distância e possuem protocolo robusto, o LoRaWAN, basicamente o módulo é uma camada, para os bytes brutos, a comunicação real seria com MQTT ou TCP/IP.\n- O ideal é um módulo de rádio como que os drones possuem, no entanto o preço é alto.\n","lastmodified":"2023-06-15T12:59:49.435182576Z","tags":null},"/notes/el%C3%A9trica/Estudo-de-Baterias-Substitutivas":{"title":"Estudo de Baterias Substitutivas","content":"\nRessalvas iniciais:\n\nAs baterias consideradas inicialmente foram baterias lítio cilíndrica, em especial pelo seu valor e pela menor necessidade de cuidados especiais que são necessários nas células prismáticas (Maior cuidado com a temperatura e pressão do ambiente).\n\nPressupondo um nível médio de tensão por célula de 3.6V. Com tensão total necessária de 72V e Energia Total aproximada de [6.5kWh](https://webthesis.biblio.polito.it/15660/), obtemos as seguintes configurações:\n \n\n---:|Sony VTC6 :| LG HG2 :| Samsung 30Q :| Samsung 30T :| Samsung 40T :| Melasta LPA542126\n---|-------------|-----|-----------|-------------|-------------|--------------------\nDimensions|18650 |18650 | 18650 | 21700 | 21700 | Primastic\nNominal capacity [mAh] | 3120 | 3000 | 3040 | 3000 | 4000 | 6000\nNominal voltage [V] | 3,6 | 3,6 | 3,6 | 3,6 | 3,6 | 3,7\nEnergy density [Wh/g] | 0,240 | 0,230 | 0,240 | 0,158 | 0,216 | 0,175\nInternal impedance [Ω] | 0,13 | 0,20 | 0,13 | 0,13 | 0,12 | \nMaximum continuous discharge current [A] | 20 | 20 | 15 | 35 | 35 | 56\nEnergy/pack of 20 [Wh] | 224.64 | 216 | 218.88 | 216 | 288 | 444\nNumber of Packs to supply 6.5kWh | 28.9 | 30.1 | 29.7 | 30.1 | 22.6 | 14.6\nTotal number of Cells | 600 | 640 | 600 | 640 | 480 | 320\nTotal weight (Only Cells) [kg] | 25.0 | 26.1 | 25.0 | 38.0 | 27.8 | 34.3\n\nTendo uma tensão total de 72V, devemos \"serializar\" 20 células. (72V\\\\3.6V)\nAlém disso, temos dois limitantes para o número de packs: a Energia Total e a Corrente de descarga. Nosso contingente de Energia atual totaliza 5.5kWh.\n\nPara calcular a Corrente que será puxada da nossa bateria, basta especificarmos a potência da nossa carga. Pelas especificações, obtemos: 7.5kW do motor, 0.6kW em perdas do Inversor e 0.4kW de componentes eletrônicos, obtemos um total de 8.5kW.\u003cbr/\u003e\nPortanto, podemos esperar uma corrente de 120A (8.5kW\\\\72V). Criando um limitante mínimo para cada possível célula:\n\n---|Sony VTC6 | LG HG2 | Samsung 30Q | Samsung 30T | Samsung 40T | Melasta LPA542126\n---|-------------|-----|-----------|-------------|-------------|--------------------\nMaximum continuous discharge current [A] | 20 | 20 | 15 | 35 | 35 | 56\nMinimum number of parallel 20 cells' packs to support the expected system's current| 6.0 | 6.0 | 8.0 | 3.4 | 3.4 | 2.1\n","lastmodified":"2023-06-15T12:59:49.435182576Z","tags":null},"/notes/el%C3%A9trica/Inversor-de-Frequ%C3%AAncia":{"title":"Inversor de Frequência","content":"\n# Introdução\nUm inversor de frequência é um dispositivo eletrônico que é usado para controlar a velocidade de um motor elétrico. Ele faz isso alterando a frequência da corrente elétrica que alimenta o motor. Quando a frequência da corrente é aumentada, a velocidade do motor também aumenta, e quando a frequência é diminuída, a velocidade do motor diminui.\n\n# Funcionamento\n\nO funcionamento de um inversor de frequência é relativamente simples. Ele consiste basicamente em um conversor de CC para CA. O inversor de frequência recebe uma fonte de corrente contínua de entrada e a converte em corrente alternada de saída com uma frequência (e corrente) ajustável. A corrente alternada de saída é então usada para alimentar o motor elétrico, alterando sua velocidade de acordo com a frequência da corrente.\n\n# Nosso Carro\n\nNo nosso carro utilizamos o CVW300, um inversor de frequência da WEG projetado para ser usado em veículos elétricos. Ele é capaz de controlar motores elétricos trifásicos de baixa tensão e é compatível com tensões de bateria de 24 a 72 VDC. Ele possui um controle vetorial embutido e fácil configuração e ajuste através de uma interface humano-máquina externa (similar à um controle remoto). Nossas aplicações driverless (sem motoristas) são suportadas nativamente por comunicações digitais RS485 e [[CANopen]].","lastmodified":"2023-06-15T12:59:49.435182576Z","tags":null},"/notes/telemetria/simulador":{"title":"Simulador EUFS","content":"\nDecidimos por usar um simulador quase de acordo com as necessidades do projeto. Usamos uma versão modificada do simulador da equipe de Formula da Universidade de Edimburgo. Em caso de dúvidas, sinta-se convidado(a) a enviar criar uma issue no github.\n\n## Como instalar o simulador\nInfelizmente somente funciona em linux, algumas dependências do simulador são do linux apesar da possibilidade de usar o ROS no Windows. No entanto, é possível usar o WSL ou o VirtualBox.\n\nOBS.: o site do EUFS lista Ubuntu 22 e ROS Galactic, mas aqui usamos outras versões. \n\n### Requerimentos\n- Ubuntu 22.04\n- git\n- lsb_release\n- ROS 2 Humble\n\n### Primeiros passos\nPrimeiramente, execute\n```\nsudo add-apt-repository main\nsudo add-apt-repository universe\nsudo apt install lsb-core lsb-release -y\n```\nServe para que o script do ROS detecte a versão correta do Ubuntu, isso realmente deu uma vez erro e consumiu muito tempo. \n\nEm seguida vá na página do \u003ca href=\"https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debians.html\"\u003eROS Humble\u003c/a\u003e, seguindo os passos tudo deve funcionar normalmente. Quando for fazer o `sudo apt install ros-humble-desktop`, não faça, faça isso: `sudo apt install ros-humble-desktop`, para instalar todos os pacotes. Ainda vai faltar, então faça isso:\n```\nsudo apt install ros-humble-desktop-full\n```\ne depois instale esses pacotes:\n```\nsudo apt install ros-humble-gazebo-ros ros-humble-ackermann-msgs\n```\n\nAgora para outras dependências do simulador, faça\n```\npip3 install colcon-common-extensions -U\n# se você não tiver python:\nsudo apt install python3 python3-pip\n```\n\nFaça:\n(Obs.: não coloque o simulador numa pasta cujo nome tenha acentos ou espaços como, ex.: Zé Maria, isso impede que o seu terminal encontre a pasta de onde instalar os pacotes)\n```\ncd ~/\n\n# efetivamente fazemos o download dele\ngit clone https://github.com/Formula-E-Siara/simulador\n\n# entre no diretório\ncd simulador\n\n\necho 'export EUFS_MASTER=$(pwd)' \u003e\u003e ~/.bashrc\n\nsource ~/.bashrc\n```\n\nVamos iniciar o workspace do ros, se você não tiver feito\n```\nsource /opt/ros/humble/setup.bash\n```\n\nEsses comandos iniciam o gerenciador de pacote e instalam os pacotes do simulador que baixamos no `git clone`\n```\nsudo apt-get install python3-rosdep\nsudo rosdep init\nrosdep update\nrosdep install --from-paths $EUFS_MASTER --ignore-src -r -y\n```\n\nVolte para a pasta do simulador e faça:\n```\n# entrar na pasta\ncd $EUFS_MASTER\n\n# dentro da pasta\ncolcon build\n```\n\nNa hora de instalar o simulador siga o tutorial do EUFS normalmente, no entanto, ao ao chegar na parte de rosdep install, faça source do script do ROS, exemplo, baixei e compilei, abro a pasta que salvei e faço:\n```\n# se você usar zsh use .zsh ao invés de .bash\nsource ./install/setup.bash\n```\nSe faltarem módulos na hora, pegue o nome deles e substitua underline por \"-\", e faça conforme o exemplo: \n```\n# exemplo ackermann_msgs\nsudo apt install ros-humble-ackermann-msgs\n```\nDepois colcon build e pronto. Daqui sempre que for usar o simulador faça, entre na pasta do simulador e faça\n```\n# caso não estiver na pasta, faça:\ncd ~/eufs_modified \u0026\u0026 . install/setup.bash\n# caso estiver na pasta faça\n. install/setup.bash\n# se não der certo substitua o . por source\n\n# para iniciar o simulador\nros2 launch eufs_launcher eufs_launcher.launch.py\n```\n","lastmodified":"2023-06-15T12:59:49.435182576Z","tags":null}}